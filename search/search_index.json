{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Heurist ETL","text":"<p>This Python package Extracts, Transforms, and Loads (ETL) data from a Heurist database server into a local DuckDB database file.</p> <ul> <li>Installation &amp; configuration</li> <li>Basic command-line usage</li> <li>Integrate API client in Python code</li> <li>Load Heurist data into R-studio</li> </ul> <p></p> <pre><code>$ pip install \\\n--index-url https://test.pypi.org/simple/ \\\n--extra-index-url https://pypi.org/simple \\\nheurist\n</code></pre>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>heurist download -f [file]</code> - Load all the records of a certain record group type into a DuckDB database file. There is also the option to export the transformed tables into CSV files for each record type.</li> <li><code>heurist record -t [record-type]</code> - Simply calling Heurist's API, export all of a targeted record type's records to a JSON file.</li> <li><code>heurist schema -t [output-type]</code> - Transform a Heurist database schema into descriptive CSV tables for each record type or into a descriptive JSON array.</li> </ul> <p>Note: Currently, the <code>heurist</code> package has only been developed for Heurist databases hosted on Huma-Num's Heurist server. This includes nearly 2000 database instances, which is a good place to start! If you want to help develop the API client to work with other servers, consider contributing.</p>"},{"location":"#erc-funded-project","title":"ERC-funded project","text":"<p>This Python package is distributed with the Creative Commons' Attribution-ShareAlike 4.0 license.</p> <p>It was developed as part of a project funded by the European Research Council. Views and opinions expressed are however those of the author(s) only and do not necessarily reflect those of the European Union or the European Research Council. Neither the European Union nor the granting authority can be held responsible for them.</p>"},{"location":"legal/","title":"ERC-funded project","text":""},{"location":"legal/#_1","title":"Credits","text":"<p>This Python package is distributed with the Creative Commons' Attribution-ShareAlike 4.0 license.</p>"},{"location":"legal/#credits","title":"Credits","text":"<ul> <li>Architect: Kelly Christensen</li> <li>Maintainers:<ul> <li>Kelly Christensen</li> </ul> </li> <li>Development context:<ul> <li>LostMa project</li> <li>Project leader: Jean-Baptiste Camps</li> </ul> </li> </ul>"},{"location":"legal/#erc-disclaimer","title":"ERC Disclaimer","text":"<p>It was developed as part of a project funded by the European Research Council. Views and opinions expressed are however those of the author(s) only and do not necessarily reflect those of the European Union or the European Research Council. Neither the European Union nor the granting authority can be held responsible for them.</p> <p></p>"},{"location":"development/code_of_conduct/","title":"Code of Conduct","text":"<p>Warning: This documentation is under development.</p>"},{"location":"development/contributing/","title":"Contributing File","text":"<p>Warning: This documentation is under development.</p> <p>Overall workflow:</p> <ol> <li> <p>From the GitHub repository, open an issue about what you want to contribute.</p> </li> <li> <p>Develop your contribution on the development (<code>dev</code>) branch of the git repository.</p> </li> <li> <p>Run linting and tests locally. Affirm that everything is passing.</p> </li> <li> <p>Push changes to the development branch.</p> </li> <li> <p>From the GitHub repository, make a pull request.</p> </li> </ol>"},{"location":"development/contributing/#set-up","title":"Set up","text":"<p>Install the project and set up the environment.</p>"},{"location":"development/contributing/#ide","title":"IDE","text":"<p>If you're using VS Code, apply the example settings.</p> <pre><code>mkdir .vscode\ncp vscode-settings.example.json .vscode/settings.json\n</code></pre>"},{"location":"development/contributing/#git-python","title":"Git &amp; Python","text":""},{"location":"development/contributing/#repository","title":"Repository","text":"<p>Clone the repository.</p> <pre><code>git clone git@github.com:LostMa-ERC/heurist-etl-pipeline.git\n</code></pre>"},{"location":"development/contributing/#virtual-environment","title":"Virtual Environment","text":"<p>Set up a virtual Python environment and install the package.</p> <pre><code>pip install --upgrade pip poetry\npoetry install\n</code></pre>"},{"location":"development/contributing/#development-branch","title":"Development branch","text":"<p>Move to the git repository's development (<code>dev</code>) branch. If you've never worked on the development branch, create it with <code>checkout -b</code> instead of <code>checkout</code>.</p> <pre><code>git checkout dev\ngit pull\n</code></pre>"},{"location":"development/contributing/#development","title":"Development","text":"<p>Before pushing changes to the repository, locally run linting and testing. These checks will be run again and for all covered Python versions when pushed to the remote repository.</p>"},{"location":"development/contributing/#style-guide","title":"Style guide","text":"<ol> <li> <p>Module names are written in snake case.</p> <ul> <li>Example: <code>record_validator.py</code></li> <li>An exception is made for the modules of the <code>pydantic.BaseXmlModel</code> models in <code>heurist/models/structural</code>, i.e. <code>DetailTypes.py</code>.</li> </ul> </li> <li> <p>Classes are written in camel case, i.e. <code>HeuristAPIClient</code>.</p> </li> <li> <p>Functions and class methods have docstrings written in Google's format.</p> <ul> <li>When describing what the function or method does, the tense is in the imperative, i.e. \"Construct a URL from path parameters.\"</li> <li>When a function or method's parameters can be written in a single line and/or don't depend on complex class instances, write unit tests in the docstring with <code>doctest</code>.<ul> <li>Preface the shell instructions with <code>Examples:</code>.</li> <li>On the next line, indent by 4 spaces before the doctest string <code>&gt;&gt;&gt; 1+1</code>.</li> </ul> </li> </ul> </li> <li> <p>The location of test modules depends on whether they're end-to-end (<code>tests/e2e</code>), integration (<code>tests/integration</code>), or unit tests (<code>tests/unit</code>).</p> <ul> <li>From the relevant test directory, the test module is placed in a subdirectory named after the package's corresponding subdirectory.</li> <li>For example, a unit test about <code>heurist/api/client.py</code> is written in the subdirectory <code>tests/unit/api</code>.</li> <li>An exception is made for end-to-end tests, which test CLI commands from the <code>tests/e2e</code> directory.</li> </ul> </li> <li> <p>Test modules are written in snake case and their name starts with the element being tested, followed by <code>_test.py</code> at the end.</p> <ul> <li>For example, a unit test about <code>heurist/api/client.py</code> is written in <code>tests/unit/api/client_test.py</code></li> </ul> </li> <li> <p>Complex SQL queries are written in individual SQL files in the <code>sql/</code> directory, i.e. <code>sql/query.sql</code>. Then, the query's parsed text is read in the <code>sql/__init__.py</code> module and made available as a constant, as follows:</p> </li> </ol> <pre><code>sql_file = Path(__file__).parent.joinpath(\"query.sql\")\n\nwith open(sql_file) as f:\n    QUERY = f.read()\n</code></pre>"},{"location":"development/contributing/#linting","title":"Linting","text":"<pre><code>poetry run flake8 --extend-exclude ./heurist/mock_data/ --max-line-length 88\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":"<pre><code>poetry run pytest\n</code></pre>"},{"location":"development/coverage/","title":"Badges","text":"<p>This repository has 2 generated badges related to testing coverage. They require the <code>coverage</code> and <code>genbadge</code> Python libraries.</p>"},{"location":"development/coverage/#set-up-development-environment","title":"Set up development environment","text":"<p>In your virtual Python environment, run the following:</p> <pre><code>pip install --upgrade pip poetry\npoetry install\n</code></pre>"},{"location":"development/coverage/#generate-badges","title":"Generate badges","text":"<p>Run the prepared <code>gen_badges.sh</code> script in the <code>./scripts</code> directory at the root of the GitHub repository.</p> <pre><code>bash ./scripts/gen_badges.sh\n</code></pre>"},{"location":"development/publishing/","title":"Publishing Versions","text":""},{"location":"development/publishing/#automated-workflow","title":"Automated workflow","text":"<p>It is recommended to use the automated workflow for releasing new versions of the package to PyPI.</p> <ol> <li> <p>Finish pull requests to the main branch and/or push your changes to the main branch. Make sure all changes you want in the new release are committed and pushed.</p> </li> <li> <p>Locally, use <code>poetry</code> to update the package version according to semantic versioning practices. This will modify the <code>pyproject.toml</code> file.</p> <ul> <li><code>poetry version prerelease</code></li> <li><code>poetry version patch</code></li> <li><code>poetry version minor</code></li> <li><code>poetry version major</code></li> </ul> </li> <li> <p>Track the modified <code>pyproject.toml</code> file in git.</p> <ul> <li><code>git add pyproject.toml</code>.</li> </ul> </li> <li> <p>Commit the updated <code>pyproject.toml</code> file; the message starts with <code>bump</code> and indicates the new version number.</p> <ul> <li>For example: <code>git commit -m \"bump v0.0.0\"</code>.</li> </ul> </li> <li> <p>Push the finalised <code>pyproject.toml</code> to the repository.</p> <ul> <li><code>git push</code></li> </ul> </li> <li> <p>Create a tag for the new version, starting with <code>v</code>.</p> <ul> <li>For example: <code>git tag v0.0.0</code></li> </ul> </li> <li> <p>Push the tag to the repository.</p> <ul> <li>For example: <code>git push origin v0.0.0</code></li> </ul> </li> <li> <p>Pushing a tag that starts with <code>v</code> will trigger the workflow <code>pypi-release.yml</code></p> </li> </ol>"},{"location":"development/publishing/#manual-workflow","title":"Manual workflow","text":"<p>Note: I used this blog post to design this workflow.</p>"},{"location":"development/publishing/#configure-pypi-authentication","title":"Configure PyPI authentication","text":"<p>If you haven't already, configure your PyPI authentication using your API key for that package.</p> <pre><code>poetry config repositories.test-pypi https://test.pypi.org/legacy/\npoetry config pypi-token.test-pypi pypi-YYYYYYYY\n</code></pre>"},{"location":"development/publishing/#run-tests","title":"Run tests","text":"<p>When you're ready to publish a new version of the package to PyPI, run all the tests.</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"development/publishing/#update-the-package-dependencies","title":"Update the package dependencies","text":"<p>Lock in any changes that have been made to the package's scripts and/or dependencies.</p> <pre><code>poetry lock\n</code></pre> <p>Update the package version.</p> <pre><code>poetry version prerelease\n# or\npoetry version patch\n# or\npoetry version minor\n# or\npoetry version major\n</code></pre>"},{"location":"development/publishing/#commit-the-changes","title":"Commit the changes","text":"<p>With a message indicating the new version (i.e. <code>v0.0.0</code>) updated in the <code>pyproject.toml</code>, commit the file's changes.</p> <pre><code>git add pyproject.toml\ngit commit -m \"bump v0.0.0\"\n</code></pre> <p>Build a distribution of the package with the new version name.</p> <pre><code>poetry build\n</code></pre>"},{"location":"development/publishing/#push-publish","title":"Push &amp; publish","text":"<p>Tag and push the commit to GitHub.</p> <pre><code>git tag v0.0.0\ngit push origin v0.0.0\n</code></pre> <p>Publish the committed package to PyPI.</p> <pre><code>poetry publish -r test-pypi\n</code></pre>"},{"location":"development/heuristdb/temporal/","title":"Temporal objects","text":"<p>Heurist features compound dates that offer rich metadata such as uncertainty and probability distribution. Users might know this feature as a \"compound\" date, which is how the widget calls it. Internally, Heurist refers to this as a \"temporal\" object.</p>"},{"location":"development/heuristdb/temporal/#heurists-types-of-temporal-objects","title":"Heurist's types of temporal objects","text":""},{"location":"development/heuristdb/temporal/#1-simple-date","title":"1. Simple date","text":"<p>A user can enter a simple date either with just the date or with additional metadata. This choice impacts how the API returns the result.</p> <p>When a user opens the <code>Simple Date</code> tab and saves only a date, no other metadata, the Heurist API return the date as the direct and only value of <code>\"value\"</code>. See the example below of a year being entered.</p> <p>API JSON response (<code>date, compound, simple date</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": 1188,\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre> <p>However, if the user enters a date and then attaches additional information, such as <code>\"Circa / approximate\"</code>, by clicking the radio buttons beside the date field in the compound date widget, the Heurist API returns a metadata map in <code>\"value\"</code>.</p> <p>API JSON response (<code>date, compound, simple date</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"timestamp\": {\n            \"in\": \"1188\",\n            \"type\": \"s\",\n            \"circa\": true\n        },\n        \"estMinDate\": 1188,\n        \"estMaxDate\": 1188,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre> <p>In the example above, the API describes the simple date as a <code>\"timestamp\"</code>. Furthermore, it has been given the type <code>\"s\"</code>. This type indication means the timestamp is a simple date, as opposed to a radiometric date, which are of type <code>\"c\"</code> for carbon.</p>"},{"location":"development/heuristdb/temporal/#widget-radio-buttons-heurist-api-response","title":"Widget radio buttons &amp; Heurist API response","text":"<p>If the user wants to add a degree of certainty to a simple date, they must select one of the radio buttons on the <code>Simple Date</code> widget.</p>"},{"location":"development/heuristdb/temporal/#exact-simple-date","title":"Exact simple date","text":"<p>The default selection is <code>Exact</code>, which is implied in the API's response by the absence of additional metadata.</p> <pre><code>\"timestamp\": {\n    \"in\": \"1188\",\n    \"type\": \"s\",\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#circa-date","title":"Circa date","text":"<p>If the user selects the <code>Circa / approximate</code> radio button, the Heurist API returns <code>\"circa\": true</code>.</p> <pre><code>\"timestamp\": {\n    \"in\": \"1188\",\n    \"type\": \"s\",\n    \"circa\": true\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#before-date","title":"Before date","text":"<p>If the user selects the <code>Before</code> radio button, the Heurist API returns <code>\"before\": true</code>.</p> <pre><code>\"timestamp\": {\n    \"in\": \"1188\",\n    \"type\": \"s\",\n    \"before\": true\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#after-date","title":"After date","text":"<p>If the user selects the <code>After</code> radio button, the Heurist API returns <code>\"after\": true</code>.</p> <pre><code>\"timestamp\": {\n    \"in\": \"1188\",\n    \"type\": \"s\",\n    \"after\": true\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#2-simple-range","title":"2. Simple range","text":"<p>API JSON response (<code>date, compound, simple range</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"start\": {\"earliest\": \"1120\"},\n        \"end\": {\"latest\": \"1150\"},\n        \"estMinDate\": 1120,\n        \"estMaxDate\": 1150.1231,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#3-fuzzy-range","title":"3. Fuzzy range","text":"<p>API JSON response (<code>date, compound, fuzzy range</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"start\": {\n            \"earliest\": \"1180\",\n            \"latest\": \"1231\",\n        },\n        \"end\": {\n            \"latest\": \"1250\",\n            \"earliest\": \"1246\",\n        },\n        \"estMinDate\": 1180,\n        \"estMaxDate\": 1250.1231,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#4-radiometric","title":"4. Radiometric","text":"<p>This type of date is not fully tested. The <code>heurist</code> package will still search for values in <code>value.estMinDate</code> and <code>value.estMaxDate</code> to generate the parsed date column. And for the <code>_TEMPORAL</code> column, the <code>heurist</code> package will return the whole dictionary in <code>value</code>. However, specific support and further documentation has not been developped.</p>"},{"location":"development/heuristdb/temporal/#certainty-probability-distribution","title":"Certainty, probability distribution","text":"<p>Users can measure (i) a date or date range's degree of certainty and (ii) a date range's probability distribution. Users see these two measurements' scales described with English terms, i.e. \"Conjecture\". However, the Heurist API returns a numeric translation.</p> <p>To develop the Python <code>heurist</code> API client, we must understand how Heurist manages this metadata.</p>"},{"location":"development/heuristdb/temporal/#i-determination","title":"(i) Determination","text":"<p>The compound widget allows users to specify how they have determined a date.</p> <ul> <li>Unknown</li> <li>Attested</li> <li>Conjecture</li> <li>Measurement</li> </ul> <p>The meaning of each value should be determined by the Heurist users and can vary depending on the project.</p> <p>As seen in Heurist's source code, Heurist maps these values to a 0-4 numeric scale.</p> <p>PHP source code (<code>heurist/hserv/utilities/Temporal.php</code>)</p> <pre><code>&lt;?php\n\nprivate $dictDetermination = array(\n    0=&gt;\"Unknown\",\n    1=&gt;\"Attested\",\n    2=&gt;\"Conjecture\",\n    3=&gt;\"Measurement\"\n);\n</code></pre> <p>The Heurist API returns the numeric value. For example, if a user enters a date range, 1454-1456, and indicates that this range is a conjecture, the Heurist API will return this detail with the key-value pair <code>\"determination\": \"2\"</code>.</p> <p>API JSON response (<code>date, compound, simple range</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"start\": {\"earliest\": \"1454\"},\n        \"end\": {\"latest\": \"1456\"},\n        \"determination\": \"2\",\n        \"estMinDate\": 1454,\n        \"estMaxDate\": 1456.1231,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n}\n</code></pre>"},{"location":"development/heuristdb/temporal/#ii-probability-distribution","title":"(ii) Probability distribution","text":"<p>The compound widget allows users to specify how a date range represents a probability distribution.</p> <ul> <li>Flat</li> <li>Central</li> <li>Slow Start</li> <li>Slow Finish</li> </ul> <p>For more information on the probability distribution of dates, see Peter Stokes's paper on modelling uncertainty in temporal metadata.</p> <p>As seen in Heurist's source code, Heurist maps these values to a 0-4 numeric scale.</p> <p>PHP source code (<code>heurist/hserv/utilities/Temporal.php</code>)</p> <pre><code>&lt;?php\n\nprivate $dictProfile = array(\n    0=&gt;\"Flat\",\n    1=&gt;\"Central\",\n    2=&gt;\"Slow Start\",\n    3=&gt;\"Slow Finish\"\n);\n</code></pre> <p>Below, look at the example of a fuzzy date range. At its extremes, the uncertain date is between 1180 and 1250. However, it is more probable that the earliest date is likely in the middle between 1180 and 1231, meaning it has a <code>\"Central\"</code> probability distribution. The latest date is probably between 1246 and 1250, though more likely nearer to 1246 than 1250. It has a <code>\"Slow Finish\"</code> probability distribution.</p> <p>API JSON response (<code>date, compound, fuzzy range</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"start\": {\n            \"earliest\": \"1180\",\n            \"latest\": \"1231\",\n            \"profile\": \"1\"\n        },\n        \"end\": {\n            \"latest\": \"1250\",\n            \"earliest\": \"1246\",\n            \"profile\": \"3\"\n        },\n        \"determination\": \"2\",\n        \"estMinDate\": 1180,\n        \"estMaxDate\": 1250.1231,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre> <p>Metadata about a date range's probability distribution can also be attached directly at the root of the detail's value. This occurs when the user enters a simple date range, as opposed to a fuzzy date range.</p> <p>API JSON response (<code>date, compound, simple range</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"start\": {\"earliest\": \"1120\"},\n        \"end\": {\"latest\": \"1150\"},\n        \"profile\": \"1\",\n        \"estMinDate\": 1120,\n        \"estMaxDate\": 1150.1231,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre>"},{"location":"development/heuristdb/temporal/#comments","title":"Comments","text":"<p>Compound dates can also be saved with comments. The Heurist API returns this metadata at the root of the detail's value.</p> <p>API JSON response (<code>date, compound, simple date</code>)</p> <pre><code>{\n    \"dty_ID\": 1111,\n    \"value\": {\n        \"timestamp\": {\"in\": \"1188\", \"type\": \"s\", \"circa\": true},\n        \"comment\": \"From Klein (1995)\",\n        \"estMinDate\": 1188,\n        \"estMaxDate\": 1188,\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\",\n},\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>api<ul> <li>client</li> <li>connection</li> <li>constants</li> <li>exceptions</li> <li>session</li> <li>url_builder</li> </ul> </li> <li>database<ul> <li>basedb</li> <li>database</li> </ul> </li> <li>models<ul> <li>dynamic<ul> <li>annotation</li> <li>create_model</li> <li>date</li> <li>type</li> </ul> </li> <li>structural<ul> <li>DetailTypes</li> <li>RecStructure</li> <li>RecTypeGroups</li> <li>RecTypes</li> <li>Terms</li> <li>dty</li> <li>hml_structure</li> <li>rst</li> <li>rtg</li> <li>rty</li> <li>trm</li> <li>utils</li> </ul> </li> </ul> </li> <li>schema<ul> <li>models</li> <li>rel_to_dict</li> </ul> </li> <li>sql<ul> <li>sql_safety</li> </ul> </li> <li>utils<ul> <li>constants</li> <li>rel_to_dict_array</li> </ul> </li> <li>validators<ul> <li>detail_validator</li> <li>exceptions</li> <li>parse_heurist_date</li> <li>record_validator</li> </ul> </li> <li>workflows<ul> <li>etl</li> </ul> </li> </ul>"},{"location":"reference/api/client/","title":"client","text":""},{"location":"reference/api/client/#api.client","title":"client","text":"<p>Heurist API client</p> <p>Classes:</p> <ul> <li> <code>HeuristAPIClient</code>           \u2013            <p>Client for Heurist API.</p> </li> </ul>"},{"location":"reference/api/client/#api.client.HeuristAPIClient","title":"HeuristAPIClient","text":"<pre><code>HeuristAPIClient(\n    database_name: str, login: str, password: str\n)\n</code></pre> <p>Client for Heurist API.</p> <p>Methods:</p> <ul> <li> <code>get_records</code>             \u2013              <p>Request all records of a certain type and in a certain data format.</p> </li> <li> <code>get_response_content</code>             \u2013              <p>Request resources from the Heurist server.</p> </li> <li> <code>get_structure</code>             \u2013              <p>Request the Heurist database's overall structure in XML format.</p> </li> </ul>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_records","title":"get_records","text":"<pre><code>get_records(\n    record_type_id: int,\n    form: Literal[\"xml\", \"json\"] = \"json\",\n    users: tuple[int] = (),\n) -&gt; bytes | list | None\n</code></pre> <p>Request all records of a certain type and in a certain data format.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes | list | None</code>           \u2013            <p>bytes | list | None: If XML, binary response returned from Heurist server, else JSON array.</p> </li> </ul>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_records(record_type_id)","title":"<code>record_type_id</code>","text":"(<code>int</code>)           \u2013            <p>Heurist ID of targeted record type.</p>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_records(form)","title":"<code>form</code>","text":"(<code>Literal['xml', 'json']</code>, default:                   <code>'json'</code> )           \u2013            <p>Data format for requested records. Defaults to \"json\".</p>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_records(users)","title":"<code>users</code>","text":"(<code>tuple</code>, default:                   <code>()</code> )           \u2013            <p>Array of IDs of users who added the target records.</p>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_response_content","title":"get_response_content","text":"<pre><code>get_response_content(url: str) -&gt; ByteString | None\n</code></pre> <p>Request resources from the Heurist server.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ByteString | None</code>           \u2013            <p>ByteString | None: Binary response returned from Heurist server.</p> </li> </ul>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_response_content(url)","title":"<code>url</code>","text":"(<code>str</code>)           \u2013            <p>Heurist API entry point.</p>"},{"location":"reference/api/client/#api.client.HeuristAPIClient.get_structure","title":"get_structure","text":"<pre><code>get_structure() -&gt; bytes | None\n</code></pre> <p>Request the Heurist database's overall structure in XML format.</p> <p>Returns:</p> <ul> <li> <code>bytes | None</code>           \u2013            <p>bytes | list | None: If XML, binary response returned from Heurist server,</p> </li> <li> <code>bytes | None</code>           \u2013            <p>else JSON array.</p> </li> </ul>"},{"location":"reference/api/connection/","title":"connection","text":""},{"location":"reference/api/connection/#api.connection","title":"connection","text":""},{"location":"reference/api/constants/","title":"constants","text":""},{"location":"reference/api/constants/#api.constants","title":"constants","text":"<p>Constant text variables for Heurist API.</p>"},{"location":"reference/api/exceptions/","title":"exceptions","text":""},{"location":"reference/api/exceptions/#api.exceptions","title":"exceptions","text":"<p>Classes:</p> <ul> <li> <code>APIException</code>           \u2013            <p>Problem calling Heurist API.</p> </li> <li> <code>AuthenticationError</code>           \u2013            <p>Error raised when unable to authenticate Heurist login.</p> </li> <li> <code>MissingParameterException</code>           \u2013            <p>Exception raised for a missing parameter.</p> </li> </ul>"},{"location":"reference/api/exceptions/#api.exceptions.APIException","title":"APIException","text":"<p>               Bases: <code>Exception</code></p> <p>Problem calling Heurist API.</p>"},{"location":"reference/api/exceptions/#api.exceptions.AuthenticationError","title":"AuthenticationError","text":"<pre><code>AuthenticationError(message)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Error raised when unable to authenticate Heurist login.</p>"},{"location":"reference/api/exceptions/#api.exceptions.MissingParameterException","title":"MissingParameterException","text":"<pre><code>MissingParameterException(parameter: str, env_file: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raised for a missing parameter.</p>"},{"location":"reference/api/session/","title":"session","text":""},{"location":"reference/api/session/#api.session","title":"session","text":"<p>Heurist API session</p> <p>Classes:</p> <ul> <li> <code>HeuristRequestSession</code>           \u2013            </li> </ul>"},{"location":"reference/api/session/#api.session.HeuristRequestSession","title":"HeuristRequestSession","text":"<pre><code>HeuristRequestSession(db: str, login: str, password: str)\n</code></pre> <p>Session context for a connection to the Heurist server.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>e</code>             \u2013            <p>If the requests method fails, raise that exception.</p> </li> <li> <code>AuthenticationError</code>             \u2013            <p>If the Heurist server returns a bad status code,                 raise an exception.</p> </li> </ul>"},{"location":"reference/api/session/#api.session.HeuristRequestSession(db)","title":"<code>db</code>","text":"(<code>str</code>)           \u2013            <p>Heurist database name.</p>"},{"location":"reference/api/session/#api.session.HeuristRequestSession(login)","title":"<code>login</code>","text":"(<code>str</code>)           \u2013            <p>Username.</p>"},{"location":"reference/api/session/#api.session.HeuristRequestSession(password)","title":"<code>password</code>","text":"(<code>str</code>)           \u2013            <p>User's password.</p>"},{"location":"reference/api/url_builder/","title":"url_builder","text":""},{"location":"reference/api/url_builder/#api.url_builder","title":"url_builder","text":"<p>Class to compose URIs for calling the Heurist API.</p> <p>Classes:</p> <ul> <li> <code>URLBuilder</code>           \u2013            <p>Class to construct endpoints for the Heurist API (on Huma-Num's server).</p> </li> </ul>"},{"location":"reference/api/url_builder/#api.url_builder.URLBuilder","title":"URLBuilder","text":"<pre><code>URLBuilder(\n    database_name: str, server: str = HUMA_NUM_SERVER\n)\n</code></pre> <p>Class to construct endpoints for the Heurist API (on Huma-Num's server).</p> <p>Methods:</p> <ul> <li> <code>get_db_structure</code>             \u2013              <p>URL to retrieve the database structure.</p> </li> <li> <code>get_records</code>             \u2013              <p>Build a URL to retrieve records of a certain type.</p> </li> </ul>"},{"location":"reference/api/url_builder/#api.url_builder.URLBuilder.get_db_structure","title":"get_db_structure","text":"<pre><code>get_db_structure() -&gt; str\n</code></pre> <p>URL to retrieve the database structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db = \"mock_db\"\n&gt;&gt;&gt; builder = URLBuilder(db)\n&gt;&gt;&gt; builder.get_db_structure()\n'https://heurist.huma-num.fr/heurist/hserv/structure/export/getDBStructureAsXML.php?db=mock_db'\n</code></pre> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>URL to retrieve the database structure.</p> </li> </ul>"},{"location":"reference/api/url_builder/#api.url_builder.URLBuilder.get_records","title":"get_records","text":"<pre><code>get_records(\n    record_type_id: int,\n    form: Literal[\"xml\", \"json\"] = \"xml\",\n    users: tuple = (),\n) -&gt; str\n</code></pre> <p>Build a URL to retrieve records of a certain type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db = \"mock_db\"\n&gt;&gt;&gt; builder = URLBuilder(db)\n&gt;&gt;&gt; builder.get_records(101)\n'https://heurist.huma-num.fr/heurist/export/xml/flathml.php?q=[{\"t\"%3A\"101\"}%2C{\"sortby\"%3A\"t\"}]&amp;a=1&amp;db=mock_db&amp;depth=all&amp;linkmode=direct_links'\n</code></pre> <pre><code>&gt;&gt;&gt; db = \"mock_db\"\n&gt;&gt;&gt; builder = URLBuilder(db)\n&gt;&gt;&gt; builder.get_records(102, form=\"json\")\n'https://heurist.huma-num.fr/heurist/hserv/controller/record_output.php?q=[{\"t\"%3A\"102\"}%2C{\"sortby\"%3A\"t\"}]&amp;a=1&amp;db=mock_db&amp;depth=all&amp;linkmode=direct_links&amp;format=json&amp;defs=0&amp;extended=2'\n</code></pre> <pre><code>&gt;&gt;&gt; db = \"mock_db\"\n&gt;&gt;&gt; builder = URLBuilder(db)\n&gt;&gt;&gt; builder.get_records(102, users=(2,16,))\n'https://heurist.huma-num.fr/heurist/export/xml/flathml.php?q=[{\"t\"%3A\"102\"}%2C{\"sortby\"%3A\"t\"}%2C{\"addedby\"%3A\"2%2C16\"}]&amp;a=1&amp;db=mock_db&amp;depth=all&amp;linkmode=direct_links'\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>URL to retrieve records of a certain type.</p> </li> </ul>"},{"location":"reference/api/url_builder/#api.url_builder.URLBuilder.get_records(record_type_id)","title":"<code>record_type_id</code>","text":"(<code>int</code>)           \u2013            <p>Heurist ID of the record type.</p>"},{"location":"reference/api/url_builder/#api.url_builder.URLBuilder.get_records(form)","title":"<code>form</code>","text":"(<code>Literal['xml', 'json']</code>, default:                   <code>'xml'</code> )           \u2013            <p>The format of the exported data.</p>"},{"location":"reference/database/basedb/","title":"basedb","text":""},{"location":"reference/database/basedb/#database.basedb","title":"basedb","text":"<p>Classes:</p> <ul> <li> <code>HeuristDatabase</code>           \u2013            <p>Base class for loading the original Heurist database structure.</p> </li> </ul>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase","title":"HeuristDatabase","text":"<pre><code>HeuristDatabase(\n    hml_xml: bytes,\n    conn: DuckDBPyConnection | None = None,\n    db: str = \":memory:\",\n)\n</code></pre> <p>Base class for loading the original Heurist database structure.</p> <p>Create a DuckDB database connection and populate the DuckDB database with the 5 base tables that comprise the Heurist database structure.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>create</code>             \u2013              <p>Create an empty table in the DuckDB database connection</p> </li> <li> <code>delete_existing_table</code>             \u2013              <p>If the table already exists in the DuckDB database, drop it.</p> </li> <li> <code>describe_record_schema</code>             \u2013              <p>Join the tables 'dty' (detail), 'rst' (record structure), 'rty' (record type)</p> </li> <li> <code>trim_xml_bytes</code>             \u2013              <p>Remove any extra whitespace from a potentially malformatted XML.</p> </li> </ul>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase(hml_xml)","title":"<code>hml_xml</code>","text":"(<code>bytes</code>)           \u2013            <p>Heurist database structure exported in XML format.</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase(conn)","title":"<code>conn</code>","text":"(<code>DuckDBPyConnection | None</code>, default:                   <code>None</code> )           \u2013            <p>A DuckDB database connection.                 Defaults to None.</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase(db)","title":"<code>db</code>","text":"(<code>str</code>, default:                   <code>':memory:'</code> )           \u2013            <p>Path to the DuckDB database. Defaults to \":memory:\".</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.create","title":"create","text":"<pre><code>create(name: str, model: BaseXmlModel) -&gt; None\n</code></pre> <p>Create an empty table in the DuckDB database connection based on a Pydantic model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set up the database class and parse a table model.\n&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt; db = HeuristDatabase(hml_xml=DB_STRUCTURE_XML)\n&gt;&gt;&gt; model = db.hml.RecTypeGroups.rtg\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a table for the Record Type Group (rtg) table model.\n&gt;&gt;&gt; db.create(name=\"rtg\", model=model)\n&gt;&gt;&gt; shape = db.conn.table(\"rtg\").fetchall()\n&gt;&gt;&gt; # The Record Type Group (rtg) table should have 11 columns.\n&gt;&gt;&gt; len(shape)\n11\n</code></pre> <p>Parameters:</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.create(model)","title":"<code>model</code>","text":"(<code>BaseXmlModel</code>)           \u2013            <p>A Pydantic XML model.</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.delete_existing_table","title":"delete_existing_table","text":"<pre><code>delete_existing_table(table_name: str) -&gt; None\n</code></pre> <p>If the table already exists in the DuckDB database, drop it.</p> <p>Parameters:</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.delete_existing_table(table_name)","title":"<code>table_name</code>","text":"(<code>str</code>)           \u2013            <p>Name of the table to potentially drop.</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.describe_record_schema","title":"describe_record_schema","text":"<pre><code>describe_record_schema(rty_ID: int) -&gt; DuckDBPyRelation\n</code></pre> <p>Join the tables 'dty' (detail), 'rst' (record structure), 'rty' (record type) to get all the relevant information for a specific record type, plus add the label and description of the section / separator associated with each detail (if any).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DuckDBPyRelation</code> (              <code>DuckDBPyRelation</code> )          \u2013            <p>A DuckDB Python relation that can be queried or converted.</p> </li> </ul>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.describe_record_schema(rty_ID)","title":"<code>rty_ID</code>","text":"(<code>int</code>)           \u2013            <p>ID of the targeted record type.</p>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.trim_xml_bytes","title":"trim_xml_bytes  <code>classmethod</code>","text":"<pre><code>trim_xml_bytes(xml: bytes) -&gt; bytes\n</code></pre> <p>Remove any extra whitespace from a potentially malformatted XML.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>Validated Heurist database structure in XML format.</p> </li> </ul>"},{"location":"reference/database/basedb/#database.basedb.HeuristDatabase.trim_xml_bytes(xml)","title":"<code>xml</code>","text":"(<code>bytes</code>)           \u2013            <p>Heurist database structure exported XML format.</p>"},{"location":"reference/database/database/","title":"database","text":""},{"location":"reference/database/database/#database.database","title":"database","text":"<p>Classes:</p> <ul> <li> <code>TransformedDatabase</code>           \u2013            <p>Class for building and populating SQL tables with data collected and     transformed from remote Heurist DB.</p> </li> </ul>"},{"location":"reference/database/database/#database.database.TransformedDatabase","title":"TransformedDatabase","text":"<pre><code>TransformedDatabase(\n    hml_xml: bytes,\n    conn: DuckDBPyConnection | None = None,\n    db: str | None = \":memory:\",\n    record_type_groups: list[str] = [\"My record types\"],\n    require_date_object: bool = False,\n)\n</code></pre> <p>               Bases: <code>HeuristDatabase</code></p> <p>Class for building and populating SQL tables with data collected and     transformed from remote Heurist DB.</p>"},{"location":"reference/models/dynamic/annotation/","title":"annotation","text":""},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation","title":"annotation","text":"<p>Classes:</p> <ul> <li> <code>PydanticField</code>           \u2013            </li> </ul>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField","title":"PydanticField","text":"<pre><code>PydanticField(\n    dty_ID: int,\n    rst_DisplayName: str,\n    dty_Type: str,\n    rst_MaxValues: int,\n)\n</code></pre> <p>Using information of 1 detail (data field) from a Heurist record, build a             Pydantic data field annotation.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>build_field</code>             \u2013              <p>Build a Pydantic field annotation for a detail whose value will simply be the             result of the <code>RecordDetailConverter</code>, meaning not a date and not a             vocabulary term.</p> </li> <li> <code>build_term_fk</code>             \u2013              <p>Build a Pydantic field annotation for a foreign key reference to the vocabulary            term in the constructed database's trm table. This field is written to the             Pydantic model in addition to a column for the term that simply has the             label.</p> </li> </ul>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField(dty_ID)","title":"<code>dty_ID</code>","text":"(<code>int</code>)           \u2013            <p>Detail's ID.</p>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField(rst_DisplayName)","title":"<code>rst_DisplayName</code>","text":"(<code>str</code>)           \u2013            <p>Name of the detail displayed in Heurist.</p>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField(dty_Type)","title":"<code>dty_Type</code>","text":"(<code>str</code>)           \u2013            <p>Detail's data type.</p>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField(rst_MaxValues)","title":"<code>rst_MaxValues</code>","text":"(<code>int</code>)           \u2013            <p>Heurist indicator if the detail can be repeated.</p>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField.build_field","title":"build_field","text":"<pre><code>build_field() -&gt; dict\n</code></pre> <p>Build a Pydantic field annotation for a detail whose value will simply be the             result of the <code>RecordDetailConverter</code>, meaning not a date and not a             vocabulary term.</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Pydantic field annotation.</p> </li> </ul>"},{"location":"reference/models/dynamic/annotation/#models.dynamic.annotation.PydanticField.build_term_fk","title":"build_term_fk","text":"<pre><code>build_term_fk() -&gt; dict\n</code></pre> <p>Build a Pydantic field annotation for a foreign key reference to the vocabulary            term in the constructed database's trm table. This field is written to the             Pydantic model in addition to a column for the term that simply has the             label.</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Pydantic field annotation.</p> </li> </ul>"},{"location":"reference/models/dynamic/create_model/","title":"create_model","text":""},{"location":"reference/models/dynamic/create_model/#models.dynamic.create_model","title":"create_model","text":"<p>Functions:</p> <ul> <li> <code>create_record_type_model</code>             \u2013              <p>Each detail's set of metadata must be a dictionary with the following keys:</p> </li> </ul>"},{"location":"reference/models/dynamic/create_model/#models.dynamic.create_model.create_record_type_model","title":"create_record_type_model","text":"<pre><code>create_record_type_model(\n    model_name: str, detail_metadata: list[dict]\n) -&gt; BaseModel\n</code></pre> <p>Each detail's set of metadata must be a dictionary with the following keys:     dty_ID,     rst_DisplayName,     dty_Type,     rst_MaxValues</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d1 = {'dty_ID': 1,\n... 'rst_DisplayName': 'label',\n... 'dty_Type': 'enum',\n... 'rst_MaxValues': 1}\n&gt;&gt;&gt; d2 = {'dty_ID': 2,\n... 'rst_DisplayName': 'date',\n... 'dty_Type': 'date',\n... 'rst_MaxValues': 1}\n&gt;&gt;&gt; model = create_record_type_model('test', [d1, d2])\n&gt;&gt;&gt; model.__annotations__.keys()\ndict_keys(['id', 'type', 'DTY1', 'DTY1_TRM', 'DTY2'])\n</code></pre> <p>Parameters:</p> Return <p>(BaseModel): Pydantic model.</p>"},{"location":"reference/models/dynamic/create_model/#models.dynamic.create_model.create_record_type_model(model_name)","title":"<code>model_name</code>","text":"(<code>str</code>)           \u2013            <p>The model's name.</p>"},{"location":"reference/models/dynamic/create_model/#models.dynamic.create_model.create_record_type_model(detail_metadata)","title":"<code>detail_metadata</code>","text":"(<code>list[dict]</code>)           \u2013            <p>A list of metadata about each field (detail).</p>"},{"location":"reference/models/dynamic/date/","title":"date","text":""},{"location":"reference/models/dynamic/date/#models.dynamic.date","title":"date","text":""},{"location":"reference/models/dynamic/type/","title":"type","text":""},{"location":"reference/models/dynamic/type/#models.dynamic.type","title":"type","text":"<p>Dataclass to organize and convert the data type of a Record's detail.</p> <p>Classes:</p> <ul> <li> <code>FieldType</code>           \u2013            <p>Organize and convert the data types of a Record's detail.</p> </li> </ul>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType","title":"FieldType  <code>dataclass</code>","text":"<pre><code>FieldType()\n</code></pre> <p>Organize and convert the data types of a Record's detail.</p> <p>Methods:</p> <ul> <li> <code>from_detail</code>             \u2013              <p>Extract the field type from a record's detail.</p> </li> <li> <code>to_pydantic</code>             \u2013              <p>Convert Heurist field type to Python type.</p> </li> <li> <code>to_sql</code>             \u2013              <p>Convert a Heurist data type label (i.e. \"enum\") to an SQL equivalent.</p> </li> </ul>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType.from_detail","title":"from_detail  <code>classmethod</code>","text":"<pre><code>from_detail(detail: dict) -&gt; str\n</code></pre> <p>Extract the field type from a record's detail.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Field type name.</p> </li> </ul>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType.from_detail(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>Record's detail.</p>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType.to_pydantic","title":"to_pydantic  <code>classmethod</code>","text":"<pre><code>to_pydantic(datatype: str) -&gt; Any\n</code></pre> <p>Convert Heurist field type to Python type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Python type.</p> </li> </ul>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType.to_pydantic(datatype)","title":"<code>datatype</code>","text":"(<code>str</code>)           \u2013            <p>Field type name.</p>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType.to_sql","title":"to_sql  <code>classmethod</code>","text":"<pre><code>to_sql(datatype: str) -&gt; str\n</code></pre> <p>Convert a Heurist data type label (i.e. \"enum\") to an SQL equivalent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>SQL data type.</p> </li> </ul>"},{"location":"reference/models/dynamic/type/#models.dynamic.type.FieldType.to_sql(datatype)","title":"<code>datatype</code>","text":"(<code>str</code>)           \u2013            <p>Heurist data type.</p>"},{"location":"reference/models/structural/DetailTypes/","title":"DetailTypes","text":""},{"location":"reference/models/structural/DetailTypes/#models.structural.DetailTypes","title":"DetailTypes","text":"<p>Classes:</p> <ul> <li> <code>DetailTypes</code>           \u2013            <p>Dataclass for modeling all of the database structure's Detail Types.</p> </li> </ul>"},{"location":"reference/models/structural/DetailTypes/#models.structural.DetailTypes.DetailTypes","title":"DetailTypes","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass for modeling all of the database structure's Detail Types.</p> <p>Attributes:</p> <ul> <li> <code>dty</code>               (<code>list</code>)           \u2013            <p>list of instantiated dataclasses that model all of the database's Detail Types.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt; from heurist.models.structural import HMLStructure\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Parse structure\n&gt;&gt;&gt; xml = DB_STRUCTURE_XML\n&gt;&gt;&gt; hml = HMLStructure.from_xml(xml)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Test class\n&gt;&gt;&gt; first_detail_type = hml.DetailTypes.dty[0]\n&gt;&gt;&gt; first_detail_type.dty_ID\n1\n&gt;&gt;&gt; singular_pointer = [d for d in hml.DetailTypes.dty if d.dty_ID == 1295][0]\n&gt;&gt;&gt; singular_pointer.dty_PtrTargetRectypeIDs\n[101]\n&gt;&gt;&gt; plural_pointer = [d for d in hml.DetailTypes.dty if d.dty_ID == 1256][0]\n&gt;&gt;&gt; plural_pointer.dty_PtrTargetRectypeIDs\n[101, 105, 106]\n</code></pre>"},{"location":"reference/models/structural/RecStructure/","title":"RecStructure","text":""},{"location":"reference/models/structural/RecStructure/#models.structural.RecStructure","title":"RecStructure","text":"<p>Classes:</p> <ul> <li> <code>RecStructure</code>           \u2013            <p>Dataclass for modeling all of the database structure's Record Structures.</p> </li> </ul>"},{"location":"reference/models/structural/RecStructure/#models.structural.RecStructure.RecStructure","title":"RecStructure","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass for modeling all of the database structure's Record Structures.</p> <p>Attributes:</p> <ul> <li> <code>rst</code>               (<code>list</code>)           \u2013            <p>list of instantiated dataclasses that model all of the database's Record Structures.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt; from heurist.models.structural import HMLStructure\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Parse structure\n&gt;&gt;&gt; xml = DB_STRUCTURE_XML\n&gt;&gt;&gt; hml = HMLStructure.from_xml(xml)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Test class\n&gt;&gt;&gt; first_record_structure = hml.RecStructure.rst[0]\n&gt;&gt;&gt; first_record_structure.rst_ID\n1\n</code></pre>"},{"location":"reference/models/structural/RecTypeGroups/","title":"RecTypeGroups","text":""},{"location":"reference/models/structural/RecTypeGroups/#models.structural.RecTypeGroups","title":"RecTypeGroups","text":"<p>Classes:</p> <ul> <li> <code>RecTypeGroups</code>           \u2013            <p>Dataclass for modeling all of the database structure's Record Type Groups.</p> </li> </ul>"},{"location":"reference/models/structural/RecTypeGroups/#models.structural.RecTypeGroups.RecTypeGroups","title":"RecTypeGroups","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass for modeling all of the database structure's Record Type Groups.</p> <p>Attributes:</p> <ul> <li> <code>rtg</code>               (<code>list</code>)           \u2013            <p>list of instantiated dataclasses that model all of the database's Record Type Groups.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt; from heurist.models.structural import HMLStructure\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Parse structure\n&gt;&gt;&gt; xml = DB_STRUCTURE_XML\n&gt;&gt;&gt; hml = HMLStructure.from_xml(xml)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Test class\n&gt;&gt;&gt; first_record_type = hml.RecTypeGroups.rtg[0]\n&gt;&gt;&gt; first_record_type.rtg_ID\n4\n</code></pre>"},{"location":"reference/models/structural/RecTypes/","title":"RecTypes","text":""},{"location":"reference/models/structural/RecTypes/#models.structural.RecTypes","title":"RecTypes","text":"<p>Classes:</p> <ul> <li> <code>RecTypes</code>           \u2013            <p>Dataclass for modeling all of the database structure's Record Types.</p> </li> </ul>"},{"location":"reference/models/structural/RecTypes/#models.structural.RecTypes.RecTypes","title":"RecTypes","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass for modeling all of the database structure's Record Types.</p> <p>Attributes:</p> <ul> <li> <code>rty</code>               (<code>list</code>)           \u2013            <p>list of instantiated dataclasses that model all of the database's Record Types.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt; from heurist.models.structural import HMLStructure\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Parse structure\n&gt;&gt;&gt; xml = DB_STRUCTURE_XML\n&gt;&gt;&gt; hml = HMLStructure.from_xml(xml)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Test class\n&gt;&gt;&gt; first_record_type = hml.RecTypes.rty[0]\n&gt;&gt;&gt; first_record_type.rty_ID\n1\n</code></pre>"},{"location":"reference/models/structural/Terms/","title":"Terms","text":""},{"location":"reference/models/structural/Terms/#models.structural.Terms","title":"Terms","text":"<p>Classes:</p> <ul> <li> <code>Terms</code>           \u2013            <p>Dataclass for modeling all of the database structure's Terms.</p> </li> </ul>"},{"location":"reference/models/structural/Terms/#models.structural.Terms.Terms","title":"Terms","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass for modeling all of the database structure's Terms.</p> <p>Attributes:</p> <ul> <li> <code>trm</code>               (<code>list</code>)           \u2013            <p>list of instantiated dataclasses that model all of the database's Terms.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt; from heurist.models.structural import HMLStructure\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Parse structure\n&gt;&gt;&gt; xml = DB_STRUCTURE_XML\n&gt;&gt;&gt; hml = HMLStructure.from_xml(xml)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Test class\n&gt;&gt;&gt; first_detail_type = hml.Terms.trm[0]\n&gt;&gt;&gt; first_detail_type.trm_ID\n12\n</code></pre>"},{"location":"reference/models/structural/dty/","title":"dty","text":""},{"location":"reference/models/structural/dty/#models.structural.dty","title":"dty","text":"<p>Classes:</p> <ul> <li> <code>DTY</code>           \u2013            <p>Dataclass to model one of the database's Detail Types. A Detail Type is the</p> </li> </ul>"},{"location":"reference/models/structural/dty/#models.structural.dty.DTY","title":"DTY","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass to model one of the database's Detail Types. A Detail Type is the     generic schema that defines the type of data one of a record's field.</p> <p>When possible, the attribute descriptions are taken from Heurist's source code.</p> <p>Attributes:</p> <ul> <li> <code>dty_ID</code>               (<code>int</code>)           \u2013            <p>Code for the detail type (field) - may vary between Heurist DBs.</p> </li> <li> <code>dty_Name</code>               (<code>str</code>)           \u2013            <p>The canonical (standard) name of the detail type, used as             default in edit form.</p> </li> <li> <code>dty_Documentation</code>               (<code>Optional[str]</code>)           \u2013            <p>Documentation of the detail type, what it             means, how defined.</p> </li> <li> <code>dty_Type</code>               (<code>Literal['freetext', 'blocktext', 'integer', 'date', 'year', 'relmarker', 'boolean', 'enum', 'relationtype', 'resource', 'float', 'file', 'geo', 'separator', 'calculated', 'fieldsetmarker', 'urlinclude']</code>)           \u2013            <p>The value-type of this             detail type, what sort of data is stored.</p> </li> <li> <code>dty_HelpText</code>               (<code>Optional[str]</code>)           \u2013            <p>The default help text displayed to the user under             the field.</p> </li> <li> <code>dty_ExtendedDescription</code>               (<code>Optional[str]</code>)           \u2013            <p>Extended text describing this detail             type, for display in rollover.</p> </li> <li> <code>dty_EntryMask</code>               (<code>Optional[str]</code>)           \u2013            <p>Data entry mask, use to control decimals on             numeric values, content of text fields etc.</p> </li> <li> <code>dty_Status</code>               (<code>Literal['reserved', 'approved', 'pending', 'open']</code>)           \u2013            <p>'Reserved' for             the system, cannot be changed; 'Approved' for community standards;             'Pending' for work in progress; 'Open' for freely modifiable/personal             record types.</p> </li> <li> <code>dty_OriginatingDBID</code>               (<code>int</code>)           \u2013            <p>Database where this detail type originated, 0 =             locally.</p> </li> <li> <code>dty_NameInOriginatingDB</code>               (<code>Optional[str]</code>)           \u2013            <p>Name used in database where this             detail type originated.</p> </li> <li> <code>dty_IDInOriginatingDB</code>               (<code>int</code>)           \u2013            <p>ID used in database where this detail type             originated.</p> </li> <li> <code>dty_DetailTypeGroupID</code>               (<code>int</code>)           \u2013            <p>The general role of this detail allowing             differentiated lists of detail types.</p> </li> <li> <code>dty_OrderInGroup</code>               (<code>int</code>)           \u2013            <p>The display order of DetailType within group,             alphabetic if equal values.</p> </li> <li> <code>dty_JsonTermIDTree</code>               (<code>Optional[str]</code>)           \u2013            <p>Tree of Term IDs to show for this field             (display-only header terms set in HeaderTermIDs).</p> </li> <li> <code>dty_TermIDTreeNonSelectableIDs</code>               (<code>List[Optional[int]]</code>)           \u2013            <p>Term IDs to use as             non-selectable headers for this field.</p> </li> <li> <code>dty_PtrTargetRectypeIDs</code>               (<code>List[Optional[int]]</code>)           \u2013            <p>CSVlist of target Rectype IDs,             null = any.</p> </li> <li> <code>dty_FieldSetRectypeID</code>               (<code>Optional[int]</code>)           \u2013            <p>For a FieldSetMarker, the record type             to be inserted as a fieldset.</p> </li> <li> <code>dty_ShowInLists</code>               (<code>bool</code>)           \u2013            <p>Show this field type in pulldown lists etc. (always             visible in field management screen).</p> </li> <li> <code>dty_NonOwnerVisibility</code>               (<code>Literal['hidden', 'viewable', 'public']</code>)           \u2013            <p>Hidden =             visible only to owners, Viewable = any logged in user, Public = visible                 to non-logged in viewers.</p> </li> <li> <code>dty_Modified</code>               (<code>datetime</code>)           \u2013            <p>Date of last modification of this record, used to get             last updated date for table.</p> </li> <li> <code>dty_LocallyModified</code>               (<code>bool</code>)           \u2013            <p>Flags a definition element which has been modified             relative to the original source.</p> </li> <li> <code>dty_SemanticReferenceURL</code>               (<code>Optional[str]</code>)           \u2013            <p>URI to a full description or             ontological reference definition of the base field (optional).</p> </li> </ul>"},{"location":"reference/models/structural/hml_structure/","title":"hml_structure","text":""},{"location":"reference/models/structural/hml_structure/#models.structural.hml_structure","title":"hml_structure","text":"<p>Classes:</p> <ul> <li> <code>HMLStructure</code>           \u2013            <p>Parent dataclass forr modeling the entire Heurist database structure.</p> </li> </ul>"},{"location":"reference/models/structural/hml_structure/#models.structural.hml_structure.HMLStructure","title":"HMLStructure","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Parent dataclass forr modeling the entire Heurist database structure.</p> <p>Attributes:</p> <ul> <li> <code>detail_types</code>               (<code>DetailTypes</code>)           \u2013            <p>model for data nested in the DetailTypes tag.</p> </li> <li> <code>record_structures</code>               (<code>RecStructure</code>)           \u2013            <p>model for data nested in the RecStructure tag.</p> </li> <li> <code>record_types</code>               (<code>RecTypes</code>)           \u2013            <p>model for data nested in the RecTypes tag.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data import DB_STRUCTURE_XML\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Parse structure\n&gt;&gt;&gt; xml = DB_STRUCTURE_XML\n&gt;&gt;&gt; hml = HMLStructure.from_xml(xml)\n</code></pre>"},{"location":"reference/models/structural/rst/","title":"rst","text":""},{"location":"reference/models/structural/rst/#models.structural.rst","title":"rst","text":"<p>Classes:</p> <ul> <li> <code>RST</code>           \u2013            <p>Dataclass to model one of the database's Record Structures. Record Structures</p> </li> </ul>"},{"location":"reference/models/structural/rst/#models.structural.rst.RST","title":"RST","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass to model one of the database's Record Structures. Record Structures     are the fields of a Record Type.</p> <p>When possible, the attribute descriptions are taken from Heurist's source code.</p> <p>Attributes:</p> <ul> <li> <code>rst_ID</code>               (<code>int</code>)           \u2013            <p>Primary key for the record structures table</p> </li> <li> <code>rst_RecTypeID</code>               (<code>int</code>)           \u2013            <p>The record type to which this detail is allocated,             0 = all rectypes</p> </li> <li> <code>rst_DetailTypeID</code>               (<code>int</code>)           \u2013            <p>Detail type for this field or, if MSB set,             FieldSet code + 32767</p> </li> <li> <code>rst_DisplayName</code>               (<code>str</code>)           \u2013            <p>Display name for this dtl type in this rectype,             autofill with dty_Name</p> </li> <li> <code>rst_DisplayHelpText</code>               (<code>Optional[str]</code>)           \u2013            <p>The user help text to be displayed for             this detail type for this record type</p> </li> <li> <code>rst_DisplayExtendedDescription</code>               (<code>Optional[str]</code>)           \u2013            <p>The rollover text to be             displayed for this detail type for this record type</p> </li> <li> <code>rst_DisplayOrder</code>               (<code>int</code>)           \u2013            <p>A sort order for display of this detail type in the             record edit form</p> </li> <li> <code>rst_DisplayWidth</code>               (<code>int</code>)           \u2013            <p>The field width displayed for this detail type in             this record type</p> </li> <li> <code>rst_DisplayHeight</code>               (<code>int</code>)           \u2013            <p>The field height for this detail type in this record             type, only relevant for memo fields</p> </li> <li> <code>rst_DefaultValue</code>               (<code>Optional[str]</code>)           \u2013            <p>The default value for this detail type for             this record type</p> </li> <li> <code>rst_RecordMatchOrder</code>               (<code>int</code>)           \u2013            <p>Indicates order of significance in detecting             duplicate records, 1 = highest</p> </li> <li> <code>rst_CalcFunctionID</code>               (<code>Optional[int]</code>)           \u2013            <p>FK to table of function specifications for             calculating string values</p> </li> <li> <code>rst_CalcFieldMask</code>               (<code>Optional[str]</code>)           \u2013            <p>A mask string along the lines of the title             mask allowing a composite field to be generated from other fields in the             record</p> </li> <li> <code>rst_RequirementType</code>               (<code>Literal['required', 'recommended', 'optional', 'forbidden']</code>)           \u2013            </li> <li> <code>rst_NonOwnerVisibility</code>               (<code>Literal['hidden', 'viewable', 'public', 'pending']</code>)           \u2013            <p>Allows restriction of visibility of a particular field in a specified             record type</p> </li> <li> <code>rst_Status</code>               (<code>Literal['reserved', 'approved', 'pending', 'open']</code>)           \u2013            <p>Reserved             Heurist codes, approved/pending by ''Board'', and user additions</p> </li> <li> <code>rst_MayModify</code>               (<code>Literal['locked', 'discouraged', 'open']</code>)           \u2013            <p>Extent to which             detail may be modified within this record structure</p> </li> <li> <code>rst_OriginatingDBID</code>               (<code>int</code>)           \u2013            <p>Database where this record structure element             originated, 0 = locally</p> </li> <li> <code>rst_IDInOriginatingDB</code>               (<code>Optional[int]</code>)           \u2013            <p>ID used in database where this record             structure element originated</p> </li> <li> <code>rst_MaxValues</code>               (<code>int</code>)           \u2013            <p>Maximum number of values per record for this detail, 1 -             single, &gt;1 limited, NULL or 0 = no limit</p> </li> <li> <code>rst_MinValues</code>               (<code>int</code>)           \u2013            <p>If required, minimum number of values per record for this             detail</p> </li> <li> <code>rst_InitialRepeats</code>               (<code>int</code>)           \u2013            <p>Number of repeat values to be displayed for this             field when a new record is first displayed</p> </li> <li> <code>rst_DisplayDetailTypeGroupID</code>               (<code>Optional[int]</code>)           \u2013            <p>If set, places detail in             specified group instead of according to dty_DetailTypeGroup</p> </li> <li> <code>rst_FilteredJsonTermIDTree</code>               (<code>Optional[str]</code>)           \u2013            <p>JSON encoded tree of allowed             terms, subset of those defined in defDetailType. This field is no             longer used</p> </li> <li> <code>rst_PtrFilteredIDs</code>               (<code>Optional[str]</code>)           \u2013            <p>Allowed Rectypes (CSV) within list defined             by defDetailType (for pointer details) This field is no longer used</p> </li> <li> <code>rst_CreateChildIfRecPtr</code>               (<code>bool</code>)           \u2013            <p>For pointer fields, flags that new records             created from this field should be marked as children of the creating record</p> </li> <li> <code>rst_PointerMode</code>               (<code>Literal['dropdown_add', 'dropdown', 'addorbrowse', 'addonly', 'browseonly']</code>)           \u2013            <p>When adding record pointer values, default or null = show             both add and browse, otherwise only allow add or only allow             browse-for-existing</p> </li> <li> <code>rst_PointerBrowseFilter</code>               (<code>Optional[str]</code>)           \u2013            <p>When adding record pointer values,             defines a Heurist filter to restrict the list of target records browsed</p> </li> <li> <code>rst_OrderForThumbnailGeneration</code>               (<code>Optional[str]</code>)           \u2013            <p>Priority order of fields to             use in generating thumbnail, null = do not use</p> </li> <li> <code>rst_TermIDTreeNonSelectableIDs</code>               (<code>Optional[str]</code>)           \u2013            <p>Term IDs to use as             non-selectable headers for this field</p> </li> <li> <code>rst_ShowDetailCertainty</code>               (<code>bool</code>)           \u2013            <p>When editing the field, allow editng of the             dtl_Certainty value (off by default)</p> </li> <li> <code>rst_ShowDetailAnnotation</code>               (<code>bool</code>)           \u2013            <p>When editing the field, allow editng of the             dtl_Annotation value (off by default)</p> </li> <li> <code>rst_NumericLargestValueUsed</code>               (<code>Optional[int]</code>)           \u2013            <p>For numeric fields, Null =             no auto increment, 0 or more indicates largest value used so far.             Set to 0 to switch on incrementing</p> </li> <li> <code>rst_EntryMask</code>               (<code>Optional[str]</code>)           \u2013            <p>Data entry mask, use to control decimals on             numeric values, content of text fields etc. for this record type - future             implementation Aug 2017</p> </li> <li> <code>rst_Modified</code>               (<code>datetime</code>)           \u2013            <p>Date of last modification of this record, used to get             last updated date for table</p> </li> <li> <code>rst_LocallyModified</code>               (<code>int</code>)           \u2013            <p>Flags a definition element which has been modified             relative to the original source</p> </li> <li> <code>rst_SemanticReferenceURL</code>               (<code>Optional[str]</code>)           \u2013            <p>The URI to a semantic definition or             web page describing this field used within this record type</p> </li> <li> <code>rst_TermsAsButtons</code>               (<code>bool</code>)           \u2013            <p>If 1, term list fields are represented as buttons             (if single value) or checkboxes (if repeat values)</p> </li> </ul>"},{"location":"reference/models/structural/rtg/","title":"rtg","text":""},{"location":"reference/models/structural/rtg/#models.structural.rtg","title":"rtg","text":"<p>Classes:</p> <ul> <li> <code>RTG</code>           \u2013            <p>Dataclass to model one of the database's Record Type Groups. A Record Type         Group categorizes the record types in the database.</p> </li> </ul>"},{"location":"reference/models/structural/rtg/#models.structural.rtg.RTG","title":"RTG","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass to model one of the database's Record Type Groups. A Record Type         Group categorizes the record types in the database.</p> <p>When possible, the attribute descriptions are taken from Heurist's source code.</p> <p>Attributes:</p> <ul> <li> <code>rtg_ID</code>               (<code>int</code>)           \u2013            <p>Description.</p> </li> <li> <code>rtg_Name</code>               (<code>str</code>)           \u2013            <p>Description.</p> </li> <li> <code>rtg_Domain</code>               (<code>str</code>)           \u2013            <p>Description.</p> </li> <li> <code>rtg_Description</code>               (<code>Optional[str]</code>)           \u2013            <p>Description.</p> </li> <li> <code>rtg_Modified</code>               (<code>datetime</code>)           \u2013            <p>Description.</p> </li> </ul>"},{"location":"reference/models/structural/rty/","title":"rty","text":""},{"location":"reference/models/structural/rty/#models.structural.rty","title":"rty","text":"<p>Classes:</p> <ul> <li> <code>RTY</code>           \u2013            <p>Dataclass to model one of the database's Record Types. A Record Type is the         schema for an entity in the database.</p> </li> </ul>"},{"location":"reference/models/structural/rty/#models.structural.rty.RTY","title":"RTY","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass to model one of the database's Record Types. A Record Type is the         schema for an entity in the database.</p> <p>When possible, the attribute descriptions are taken from Heurist's source code.</p> <p>Attributes:</p> <ul> <li> <code>rty_ID</code>               (<code>int</code>)           \u2013            <p>Record type code, widely used to reference record types, primary             key</p> </li> <li> <code>rty_Name</code>               (<code>str</code>)           \u2013            <p>The name which is used to describe this record (object) type</p> </li> <li> <code>rty_OrderInGroup</code>               (<code>int</code>)           \u2013            <p>Ordering within record type display groups for pulldowns</p> </li> <li> <code>rty_Description</code>               (<code>str</code>)           \u2013            <p>Description of this record type</p> </li> <li> <code>rty_TitleMask</code>               (<code>str</code>)           \u2013            <p>Mask to build a composite title by combining field values</p> </li> <li> <code>rty_CanonicalTitleMask</code>               (<code>str</code>)           \u2013            <p>Version of the mask converted to detail codes             for processing</p> </li> <li> <code>rty_Plural</code>               (<code>Optional[str]</code>)           \u2013            <p>Plural form of the record type name, manually             entered</p> </li> <li> <code>rty_Status</code>               (<code>Literal['reserved', 'approved', 'pending', 'open']</code>)           \u2013            <p>Reserved             Heurist codes, approved/pending by ''Board'', and user additions</p> </li> <li> <code>rty_OriginatingDBID</code>               (<code>Optional[int]</code>)           \u2013            <p>Database where this record type             originated, 0 = locally</p> </li> <li> <code>rty_NameInOriginatingDB</code>               (<code>Optional[str]</code>)           \u2013            <p>(Optional[str]) Name used in database where this             record type originated</p> </li> <li> <code>rty_IDInOriginatingDB</code>               (<code>Optional[int]</code>)           \u2013            <p>ID in database where this record type             originated</p> </li> <li> <code>rty_NonOwnerVisibility</code>               (<code>Literal['hidden', 'viewable', 'public', 'pending']</code>)           \u2013            <p>Allows blanket restriction of visibility of a particular record type</p> </li> <li> <code>rty_ShowInLists</code>               (<code>bool</code>)           \u2013            <p>Flags if record type is to be shown in end-user             interface, 1=yes</p> </li> <li> <code>rty_RecTypeGroupID</code>               (<code>int</code>)           \u2013            <p>Record type group to which this record type belongs</p> </li> <li> <code>rty_RecTypeModelIDs</code>               (<code>str</code>)           \u2013            <p>The model group(s) to which this rectype belongs,             comma sep. list</p> </li> <li> <code>rty_FlagAsFieldset</code>               (<code>bool</code>)           \u2013            <p>0 = full record type, 1 = Fieldset = set of fields             to include in other rectypes</p> </li> <li> <code>rty_ReferenceURL</code>               (<code>Optional[str]</code>)           \u2013            <p>A semantic reference URI for, or a URL             describing, the record type</p> </li> <li> <code>rty_AlternativeRecEditor</code>               (<code>Optional[str]</code>)           \u2013            <p>Name or URL of alternative record             editor function to be used for this rectype</p> </li> <li> <code>rty_Type</code>               (<code>Literal['normal', 'relationship', 'dummy']</code>)           \u2013            <p>Use to flag special             record types to trigger special functions</p> </li> <li> <code>rty_ShowURLOnEditForm</code>               (<code>bool</code>)           \u2013            <p>Determines whether special URL field is shown at             the top of the edit form</p> </li> <li> <code>rty_ShowDescriptionOnEditForm</code>               (<code>bool</code>)           \u2013            <p>Determines whether the record type             description field is shown at the top of the edit form</p> </li> <li> <code>rty_Modified</code>               (<code>datetime</code>)           \u2013            <p>Date of last modification of this record, used to get             last updated date for table</p> </li> <li> <code>rty_LocallyModified</code>               (<code>bool</code>)           \u2013            <p>Flags a definition element which has been modified             relative to the original source</p> </li> </ul>"},{"location":"reference/models/structural/trm/","title":"trm","text":""},{"location":"reference/models/structural/trm/#models.structural.trm","title":"trm","text":"<p>Classes:</p> <ul> <li> <code>TRM</code>           \u2013            <p>Dataclass to model one of the database's vocabulary terms.</p> </li> </ul>"},{"location":"reference/models/structural/trm/#models.structural.trm.TRM","title":"TRM","text":"<p>               Bases: <code>BaseXmlModel</code></p> <p>Dataclass to model one of the database's vocabulary terms.</p> <p>When possible, the attribute descriptions are taken from Heurist's source code.</p>"},{"location":"reference/models/structural/utils/","title":"utils","text":""},{"location":"reference/models/structural/utils/#models.structural.utils","title":"utils","text":"<p>Module for utilities commonly used by XML parsers in schemas.</p> <p>Functions:</p> <ul> <li> <code>split_ids</code>             \u2013              <p>Function for converting a string representation of a list of quoted integers         into a Python list object.</p> </li> </ul>"},{"location":"reference/models/structural/utils/#models.structural.utils.split_ids","title":"split_ids","text":"<pre><code>split_ids(input: str) -&gt; list\n</code></pre> <p>Function for converting a string representation of a list of quoted integers         into a Python list object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = \"3001,3110,3113,3288\"\n&gt;&gt;&gt; split_ids(s)\n[3001, 3110, 3113, 3288]\n&gt;&gt;&gt; s = '[\\\"3001\\\",\\\"3110\\\",\\\"3113\\\",\\\"3288\\\"]'\n&gt;&gt;&gt; split_ids(s)\n[3001, 3110, 3113, 3288]\n&gt;&gt;&gt; l = ['[\\\"3001\\\",\\\"3110\\\",\\\"3113\\\",\\\"3288\\\"]']\n&gt;&gt;&gt; split_ids(l)\n[3001, 3110, 3113, 3288]\n&gt;&gt;&gt; s = '[]'\n&gt;&gt;&gt; split_ids(s)\n[]\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>description</p> </li> </ul>"},{"location":"reference/models/structural/utils/#models.structural.utils.split_ids(input)","title":"<code>input</code>","text":"(<code>str | Any</code>)           \u2013            <p>List of integers.</p>"},{"location":"reference/schema/models/","title":"models","text":""},{"location":"reference/schema/models/#schema.models","title":"models","text":"<p>Functions:</p> <ul> <li> <code>convert_vocab_map_to_list</code>             \u2013              <p>Convert map generated in the SQL query to a list of vocab dictionary objects.</p> </li> </ul>"},{"location":"reference/schema/models/#schema.models.convert_vocab_map_to_list","title":"convert_vocab_map_to_list","text":"<pre><code>convert_vocab_map_to_list(\n    vocab_map: dict | None,\n) -&gt; list[dict]\n</code></pre> <p>Convert map generated in the SQL query to a list of vocab dictionary objects.</p> <p>See the SQL query in the sql/ directory. The relevant selection is:     map(list(trm_Label), list(         {             \"description\": trm_Description,             \"url\": trm_SemanticReferenceURL,             \"id\": trm_ID         })     ) AS terms</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vocab0 = {'perg': {'description': 'Parchment', 'url': None, 'id': 9782}}\n&gt;&gt;&gt; vocab1 = {'chart': {'description': 'Paper', 'url': None, 'id': 9783}}\n&gt;&gt;&gt; vocab2 = {'mixed': {'description': None, 'url': None, 'id': 9785}}\n&gt;&gt;&gt; map = vocab0 | vocab1 | vocab2\n&gt;&gt;&gt; terms = convert_vocab_map_to_list(map)\n&gt;&gt;&gt; len(terms)\n3\n&gt;&gt;&gt; terms[0]\n{'label': 'perg', 'description': 'Parchment', 'url': None, 'id': 9782}\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>list[dict]: List of vocabulary term metadata in dictionary objects.</p> </li> </ul>"},{"location":"reference/schema/models/#schema.models.convert_vocab_map_to_list(vocab_map)","title":"<code>vocab_map</code>","text":"(<code>dict | None</code>)           \u2013            <p>Map created in SQL query from aggregation function.</p>"},{"location":"reference/schema/rel_to_dict/","title":"rel_to_dict","text":""},{"location":"reference/schema/rel_to_dict/#schema.rel_to_dict","title":"rel_to_dict","text":"<p>Functions:</p> <ul> <li> <code>convert_rty_description</code>             \u2013              <p>Convert the SQL result of the joined record type schema description into     a Python dictionary.</p> </li> </ul>"},{"location":"reference/schema/rel_to_dict/#schema.rel_to_dict.convert_rty_description","title":"convert_rty_description","text":"<pre><code>convert_rty_description(\n    description: DuckDBPyRelation,\n) -&gt; dict\n</code></pre> <p>Convert the SQL result of the joined record type schema description into     a Python dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Dictionary representation of a record's schema.</p> </li> </ul>"},{"location":"reference/schema/rel_to_dict/#schema.rel_to_dict.convert_rty_description(description)","title":"<code>description</code>","text":"(<code>DuckDBPyRelation</code>)           \u2013            <p>Relation from SQL query.</p>"},{"location":"reference/sql/sql_safety/","title":"sql_safety","text":""},{"location":"reference/sql/sql_safety/#sql.sql_safety","title":"sql_safety","text":"<p>Classes:</p> <ul> <li> <code>SafeSQLName</code>           \u2013            </li> </ul>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName","title":"SafeSQLName","text":"<pre><code>SafeSQLName()\n</code></pre> <p>Methods:</p> <ul> <li> <code>create_column_name</code>             \u2013              <p>Create an SQL-safe column name for the Pydantic data field.</p> </li> <li> <code>create_table_name</code>             \u2013              <p>Create SQL-safe table name for the record's data model.</p> </li> <li> <code>remove_characters</code>             \u2013              <p>Simplify and remove undesirable characters from a string.</p> </li> </ul>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.create_column_name","title":"create_column_name","text":"<pre><code>create_column_name(field_name: str, field_type: str) -&gt; str\n</code></pre> <p>Create an SQL-safe column name for the Pydantic data field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>SQL-safe column name.</p> </li> </ul>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.create_column_name(field_name)","title":"<code>field_name</code>","text":"(<code>str</code>)           \u2013            <p>Displayed name of the field (detail) in Heurist.</p>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.create_column_name(field_type)","title":"<code>field_type</code>","text":"(<code>str</code>)           \u2013            <p>Heurist type of the field (detail).</p>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.create_table_name","title":"create_table_name","text":"<pre><code>create_table_name(record_name: str) -&gt; str\n</code></pre> <p>Create SQL-safe table name for the record's data model.</p> <p>Examples:</p> <p>heurist_name = \"Sequence\" SafeSQLName().create_table_name(heurist_name) 'SequenceTable'</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>SQL-safe name for the record type's table.</p> </li> </ul>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.create_table_name(record_name)","title":"<code>record_name</code>","text":"(<code>str</code>)           \u2013            <p>Name of the Heurist record type.</p>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.remove_characters","title":"remove_characters  <code>classmethod</code>","text":"<pre><code>remove_characters(s: str) -&gt; str\n</code></pre> <p>Simplify and remove undesirable characters from a string.</p> <p>Examples:</p> <p>s = \"Author or Creator (Person, Organization)\" SafeSQLName.remove_characters(s) 'Author or Creator'</p> <p>s = \"Status_trad_freetext\" SafeSQLName.remove_characters(s) 'Status_trad_freetext'</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Cleaned string.</p> </li> </ul>"},{"location":"reference/sql/sql_safety/#sql.sql_safety.SafeSQLName.remove_characters(s)","title":"<code>s</code>","text":"(<code>str</code>)           \u2013            <p>Input string.</p>"},{"location":"reference/utils/constants/","title":"constants","text":""},{"location":"reference/utils/constants/#utils.constants","title":"constants","text":""},{"location":"reference/utils/rel_to_dict_array/","title":"rel_to_dict_array","text":""},{"location":"reference/utils/rel_to_dict_array/#utils.rel_to_dict_array","title":"rel_to_dict_array","text":""},{"location":"reference/validators/detail_validator/","title":"detail_validator","text":""},{"location":"reference/validators/detail_validator/#validators.detail_validator","title":"detail_validator","text":"<p>Class for converting a record's detail before the Pydantic model validation.</p> <p>Classes:</p> <ul> <li> <code>DetailValidator</code>           \u2013            <p>In Heurist, a record's \"detail\" is what is more commonly known as an attribute,         dimension, or a data field.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator","title":"DetailValidator","text":"<p>In Heurist, a record's \"detail\" is what is more commonly known as an attribute,         dimension, or a data field.</p> <p>This class features methods to extract the key value from Heurist's JSON         formatting for all data types in Heurist's system.</p> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              <p>Based on the data type, convert the record's nested detail to a flat value.</p> </li> <li> <code>validate_date</code>             \u2013              <p>Build the variable date value into a structured dictionary.</p> </li> <li> <code>validate_enum</code>             \u2013              <p>Extract the value of an enum field.</p> </li> <li> <code>validate_file</code>             \u2013              <p>Extract the value of a file field.</p> </li> <li> <code>validate_geo</code>             \u2013              <p>Extract the value of a geo field.</p> </li> <li> <code>validate_resource</code>             \u2013              <p>Extract the value of a resource (foreign key) field.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.convert","title":"convert  <code>classmethod</code>","text":"<pre><code>convert(detail: dict) -&gt; str | int | list | dict | None\n</code></pre> <p>Based on the data type, convert the record's nested detail to a flat value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | int | list | dict | None</code>           \u2013            <p>str | int | list | dict | None: Flattened value of the data field.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.convert(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>One of the record's details (data fields).</p>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_date","title":"validate_date  <code>classmethod</code>","text":"<pre><code>validate_date(detail: dict) -&gt; dict\n</code></pre> <p>Build the variable date value into a structured dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Test temporal object\n&gt;&gt;&gt; from heurist.mock_data.date.compound_single import DETAIL\n&gt;&gt;&gt; value = DetailValidator.convert(DETAIL)\n&gt;&gt;&gt; value['start']['earliest']\ndatetime.datetime(1180, 1, 1, 0, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Test direct date value\n&gt;&gt;&gt; from heurist.mock_data.date.simple_single import DETAIL\n&gt;&gt;&gt; value = DetailValidator.convert(DETAIL)\n&gt;&gt;&gt; value['value']\ndatetime.datetime(2024, 3, 19, 0, 0)\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Structured metadata for a Heurist date object.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_date(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>Record's detail.</p>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_enum","title":"validate_enum  <code>classmethod</code>","text":"<pre><code>validate_enum(detail: dict) -&gt; str\n</code></pre> <p>Extract the value of an enum field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Value of record's detail.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_enum(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>Record's detail.</p>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_file","title":"validate_file  <code>classmethod</code>","text":"<pre><code>validate_file(detail: dict) -&gt; str\n</code></pre> <p>Extract the value of a file field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Value of record's detail.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_file(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>Record's detail.</p>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_geo","title":"validate_geo  <code>classmethod</code>","text":"<pre><code>validate_geo(detail: dict) -&gt; str\n</code></pre> <p>Extract the value of a geo field.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from heurist.mock_data.geo.single import DETAIL_POINT\n&gt;&gt;&gt; DetailValidator.convert(DETAIL_POINT)\n'POINT(2.19726563 48.57478991)'\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Value of record's detail.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_geo(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>Record's detail.</p>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_resource","title":"validate_resource  <code>classmethod</code>","text":"<pre><code>validate_resource(detail: dict) -&gt; int\n</code></pre> <p>Extract the value of a resource (foreign key) field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Heurist ID of the referenced record.</p> </li> </ul>"},{"location":"reference/validators/detail_validator/#validators.detail_validator.DetailValidator.validate_resource(detail)","title":"<code>detail</code>","text":"(<code>dict</code>)           \u2013            <p>Record's detail.</p>"},{"location":"reference/validators/exceptions/","title":"exceptions","text":""},{"location":"reference/validators/exceptions/#validators.exceptions","title":"exceptions","text":"<p>Exceptions for classes that convert / transform Heurist data.</p> <p>Classes:</p> <ul> <li> <code>DateNotEnteredAsDateObject</code>           \u2013            <p>The date field was not entered as a constructed Heurist date object.</p> </li> <li> <code>RepeatedValueInSingularDetailType</code>           \u2013            <p>The detail type is limited to a maximum of 1 values</p> </li> </ul>"},{"location":"reference/validators/exceptions/#validators.exceptions.DateNotEnteredAsDateObject","title":"DateNotEnteredAsDateObject","text":"<pre><code>DateNotEnteredAsDateObject(value: int | str | float)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>The date field was not entered as a constructed Heurist date object.</p>"},{"location":"reference/validators/exceptions/#validators.exceptions.RepeatedValueInSingularDetailType","title":"RepeatedValueInSingularDetailType","text":"<pre><code>RepeatedValueInSingularDetailType(\n    type_id: int,\n    record_id: int,\n    field_name: str,\n    value_count: int,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>The detail type is limited to a maximum of 1 values but the record has more than 1 value for this detail.</p>"},{"location":"reference/validators/parse_heurist_date/","title":"parse_heurist_date","text":""},{"location":"reference/validators/parse_heurist_date/#validators.parse_heurist_date","title":"parse_heurist_date","text":"<p>Functions:</p> <ul> <li> <code>parse_heurist_date</code>             \u2013              <p>Convert Heurist's partial date representations to an ISO string format.</p> </li> </ul>"},{"location":"reference/validators/parse_heurist_date/#validators.parse_heurist_date.parse_heurist_date","title":"parse_heurist_date","text":"<pre><code>parse_heurist_date(\n    repr: str | int | float | None,\n) -&gt; datetime | None\n</code></pre> <p>Convert Heurist's partial date representations to an ISO string format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Test a string representation of a date\n&gt;&gt;&gt; v = \"2024-03-19\"\n&gt;&gt;&gt; parse_heurist_date(v)\ndatetime.datetime(2024, 3, 19, 0, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Test an integer representation of a year, i.e. circa 1188\n&gt;&gt;&gt; v = 1188\n&gt;&gt;&gt; parse_heurist_date(v)\ndatetime.datetime(1188, 1, 1, 0, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Test a float representation of a date\n&gt;&gt;&gt; v = 1250.1231\n&gt;&gt;&gt; parse_heurist_date(v)\ndatetime.datetime(1250, 12, 31, 0, 0)\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>datetime | None</code>           \u2013            <p>datetime | None: Parsed date.</p> </li> </ul>"},{"location":"reference/validators/parse_heurist_date/#validators.parse_heurist_date.parse_heurist_date(repr)","title":"<code>repr</code>","text":"(<code>str | int | float</code>)           \u2013            <p>Heurist representation             of a date.</p>"},{"location":"reference/validators/record_validator/","title":"record_validator","text":""},{"location":"reference/validators/record_validator/#validators.record_validator","title":"record_validator","text":""},{"location":"reference/workflows/etl/","title":"etl","text":""},{"location":"reference/workflows/etl/#workflows.etl","title":"etl","text":"<p>Functions:</p> <ul> <li> <code>extract_transform_load</code>             \u2013              <p>Workflow for (1) extracting, transforming, and loading the Heurist database         architecture into a DuckDB database and (2) extracting, transforming,         and loading record types' records into the created DuckDB database.</p> </li> </ul>"},{"location":"reference/workflows/etl/#workflows.etl.extract_transform_load","title":"extract_transform_load","text":"<pre><code>extract_transform_load(\n    client: HeuristAPIClient,\n    duckdb_connection: DuckDBPyConnection,\n    user: tuple = (),\n    require_compound_dates: bool = False,\n    record_group_names: tuple = DEFAULT_RECORD_GROUPS,\n) -&gt; None\n</code></pre> <p>Workflow for (1) extracting, transforming, and loading the Heurist database         architecture into a DuckDB database and (2) extracting, transforming,         and loading record types' records into the created DuckDB database.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>duckdb.DuckDBPyConnection: Open connection to the created DuckDB database.</p> </li> </ul>"},{"location":"reference/workflows/etl/#workflows.etl.extract_transform_load(client)","title":"<code>client</code>","text":"(<code>HeuristAPIClient</code>)           \u2013            <p>Instance of a Heurist API client.</p>"},{"location":"reference/workflows/etl/#workflows.etl.extract_transform_load(duckdb_connection)","title":"<code>duckdb_connection</code>","text":"(<code>DuckDBPyConnection</code>)           \u2013            <p>Connection to a DuckDB database.</p>"},{"location":"reference/workflows/etl/#workflows.etl.extract_transform_load(user)","title":"<code>user</code>","text":"(<code>tuple</code>, default:                   <code>()</code> )           \u2013            <p>IDs (integers) of targeted users.</p>"},{"location":"reference/workflows/etl/#workflows.etl.extract_transform_load(require_compound_dates)","title":"<code>require_compound_dates</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to impose strict validation             on Heurist date types. Defaults to False.</p>"},{"location":"reference/workflows/etl/#workflows.etl.extract_transform_load(record_group_names)","title":"<code>record_group_names</code>","text":"(<code>tuple</code>, default:                   <code>DEFAULT_RECORD_GROUPS</code> )           \u2013            <p>Names of the record group types. Must include at             least 1. Defaults to (\"My record types\").</p>"},{"location":"usage/","title":"Usage","text":"<p>This package's primary use is as a command-line interface (CLI). It's meant to efficiently extract, transform, and load data from their Heurist database into local CSV, JSON, and DuckDB files.</p> <p>Secondarily, you can also exploit certain modules, such as the API client, for your own Python development. For this secondary use, read the documentation here.</p>"},{"location":"usage/#installation","title":"Installation","text":""},{"location":"usage/#requirements","title":"Requirements","text":"<ul> <li>Python version 3.10 or greater</li> <li>Virtual Python environment, i.e. <code>pyenv</code>.</li> </ul>"},{"location":"usage/#steps","title":"Steps","text":"<ol> <li>If you don't have Python installed on your machine, download version 3.10 or greater.<ul> <li>Need help installing Python? Check out the Real Python blog's tutorial.</li> </ul> </li> <li>Create a new virtual environment for the package. Then activate it.<ul> <li>What's the simplest way? Check out Real Python's thorough blog post.</li> <li>I recommend naming the environment <code>heurist</code>.</li> </ul> </li> <li>Use <code>pip install</code> to install the <code>heurist</code> Python package.</li> </ol> <pre><code>$ pip install \\\n--index-url https://test.pypi.org/simple/ \\\n--extra-index-url https://pypi.org/simple \\\nheurist\n</code></pre>"},{"location":"usage/#configure-the-cli","title":"Configure the CLI","text":"<p>All of the <code>heurist</code> subcommands require connecting to your Heurist database.</p>"},{"location":"usage/#option-1-manually-declare-login-credentials","title":"Option 1: Manually declare login credentials","text":"<p>After the <code>heurist</code> command, provide the Heurist database name (<code>--database</code>, <code>-d</code>) as well as the username (<code>--login</code>, <code>-l</code>) and password (<code>--password</code>, <code>-p</code>) for a user with access to the Heurist database.</p> <pre><code>heurist -d YOUR_DATABASE -l \"your.username\" -p \"your-password\"\n</code></pre>"},{"location":"usage/#option-2-set-environment-variables","title":"Option 2: Set environment variables","text":"<p>From wherever you're running the command in the terminal, create a <code>.env</code> file.</p> <pre><code>touch .env\n</code></pre> <p>Then, using some kind of simple text editor (and replacing the defaults with your login credentials), add the following 3 lines to the <code>.env</code> file:</p> <pre><code>DB_NAME=your_database\nDB_LOGIN=your.username\nDB_PASSWORD=your-password\n</code></pre> <p>With the <code>.env</code> file, you can run any <code>heurist</code> subcommand without needing to provide any other information.</p> <pre><code>$ heurist --help\nUsage: heurist [OPTIONS] COMMAND [ARGS]...\n\n  Group CLI command for connecting to the Heurist DB\n\nOptions:\n  --version            Show the version and exit.\n  -d, --database TEXT  Name of the Heurist database\n  -l, --login TEXT     Login name for the database user\n  -p, --password TEXT  Password for the database user\n  --debugging          Whether to run in debug mode, default false.\n  --help               Show this message and exit.\n\nCommands:\n  download  Export data of records of 1 or more record group types.\n  record    Get a JSON export of a certain record type.\n  schema    Generate documentation about the database schema.\n</code></pre>"},{"location":"usage/#cli-commands","title":"CLI commands","text":""},{"location":"usage/#download-groups-of-records","title":"Download groups of records","text":"<p>For full documentation on this command, see the basic usage of <code>download</code>.</p> <pre><code>heurist download -f NEW_DATABASE.db\n</code></pre>"},{"location":"usage/#export-a-record-type-from-heurists-api","title":"Export a record type from Heurist's API","text":"<p>For full documentation on this command, see Export from API.</p> <pre><code>heurist record -t RECORD_TYPE_ID_NUMBER\n</code></pre>"},{"location":"usage/#generate-documentation-about-heurists-schema","title":"Generate documentation about Heurist's schema","text":"<p>For full documentation on this command, see Generate schema.</p> <pre><code>heurist schema -t CSV|JSON\n</code></pre>"},{"location":"usage/module/","title":"Python API Client","text":"<p>Before using the <code>heurist</code> module, review the instructions on how to install the Python package.</p>"},{"location":"usage/module/#demos","title":"Demos","text":"<p>Explore Jupyter notebooks in the GitHub repository's folder <code>demos/</code>.</p>"},{"location":"usage/module/#coding-with-the-etl-workflow","title":"Coding with the ETL workflow","text":"<p>You can integrate a Heurist database's tables into your Python application with just 3 lines of code!</p>"},{"location":"usage/module/#1-create-the-heurist-api-client","title":"1. Create the <code>heurist</code> API client","text":"<p>Create an instance of the <code>heurist</code> package's API Client. Provide the name of your Heurist database, your account's login, and your account's password.</p> <pre><code>from heurist.api.client import HeuristAPIClient\n\nclient = HeuristAPIClient(\n    database_name = HEURIST_DATABASE,\n    login = HEURIST_LOGIN,\n    password = HEURIST_PASSWORD\n)\n</code></pre>"},{"location":"usage/module/#2-create-a-duckdb-connection","title":"2. Create a DuckDB connection","text":"<p>Create a connection to a DuckDB database.</p> <pre><code>import duckdb\n\nconn = duckdb.connect()\n</code></pre> <p>To preserve the data that <code>heurist</code> extracts, transforms, and loads into the database, give the <code>connect()</code> method a path to a file, i.e. <code>duckdb.connect(\"heurist.db\")</code>. If no argument is provided, <code>duckdb.connect()</code> creates an in-memory database connection.</p>"},{"location":"usage/module/#3-run-the-etl-process","title":"3. Run the ETL process","text":"<p>To load all your custom records, meaning all those of types in your \"My record types\" group, run the <code>extract_transform_load()</code> function with all its defaults, simply providing your (1) API client and (2) DuckDB connection.</p> <pre><code>from heurist.workflows import extract_transform_load\n\nextract_transform_load(\n    client = client,\n    duckdb_connection = conn,\n)\n</code></pre> <p>To explore all of the <code>extract_transform_load</code> function's parameters, see the source code.</p>"},{"location":"usage/module/#multiple-record-type-groups","title":"Multiple record type groups","text":"<p>If you want to recover records of types in multiple record type groups, list all of them in the <code>record_group_names</code> parameter.</p> <pre><code>extract_transform_load(\n    client = client,\n    duckdb_connection = conn,\n    record_group_names = (\"My record types\", \"Place, features\")\n)\n</code></pre>"},{"location":"usage/module/#check-your-datas-validation","title":"Check your data's validation","text":"<p>Running the <code>extract_transform_load</code> function causes log files to be generated.</p> <p>Read the <code>./validation.log</code> file to review all the records in the Heurist database that did not pass the data validation and were not loaded into the DuckDB database. For more information, see the section on logs.</p>"},{"location":"usage/module/#duckdb-python-as-a-pivot-format","title":"DuckDB Python as a pivot format","text":"<p>Having loaded the Heurist records into a DuckDB database, you can begin taking advantage of DuckDB's Python client.</p>"},{"location":"usage/module/#heurist-duckdb-to-something-else","title":"Heurist DuckDB -&gt; to something else","text":""},{"location":"usage/module/#pandas-dataframe","title":"Pandas dataframe","text":"<p>DuckDB can convert all of its relations (tables, query results, etc.) into <code>pandas</code> dataframes with <code>df()</code>. Because many data science techniques and methods are used to <code>pandas</code>, this is a very useful way to interact with the Heurist data and one of the reasons the <code>heurist</code> package uses DuckDB as a pivot format.</p> <p>Convert a Heurist table, which has been loaded into the DuckDB database, into a <code>pandas</code> dataframe.</p> <pre><code>&gt;&gt;&gt; conn.table(\"Witness\").df()\n      H-ID  type_id  ...  review_status TRM-ID             review_note\n0    47500      105  ...                  9697                  Check.\n1    47897      105  ...                  9697                  Check.\n2    47756      105  ...                  9697                  Check.\n3    47978      105  ...                  9697                  Check.\n4    47552      105  ...                  9697                  Check.\n..     ...      ...  ...                   ...                     ...\n168  48051      105  ...                  9697  Kienhorst zegt in BNM?\n169  47458      105  ...                  9697                    Ref.\n170  47454      105  ...                  9697                    Ref.\n171  47433      105  ...                  9697             Check, ref.\n172  47420      105  ...                  9697           Check, ghost.\n\n[173 rows x 36 columns]\n</code></pre> <p>Or convert SQL query results into a <code>pandas</code> dataframe.</p> <pre><code>&gt;&gt;&gt; conn.sql('SELECT * FROM Witness w JOIN TextTable t ON w.\"is_manifestation_of H-ID\" = t.\"H-ID\"').df()\n      H-ID  type_id  ...  review_status TRM-ID_1 review_note_1\n0    47792      105  ...                  9697.0        Check.\n1    48339      105  ...                  9697.0         Check\n2    47906      105  ...                  9697.0        Check.\n3    48356      105  ...                  9697.0         Check\n4    47912      105  ...                  9697.0        Check.\n..     ...      ...  ...                     ...           ...\n168  47742      105  ...                  9697.0        Check.\n169  47738      105  ...                  9697.0        Check.\n170  47725      105  ...                  9697.0        Check.\n171  47734      105  ...                  9697.0        Check.\n172  47637      105  ...                  9697.0        Check.\n\n[173 rows x 89 columns]\n</code></pre>"},{"location":"usage/module/#parquet-csv-files","title":"Parquet, CSV files","text":"<p>DuckDB's Python client also lets you export relations into modern file formats commonly used in data science, notably CSV and parquet.</p> <pre><code># Execute some SQL query on your database,\n# storing the result in a relation object\nrel = conn.sql(\"SELECT * FROM TextTable LIMIT 10\")\n\n# Write the result to a csv file\nrel.write_csv(\"my_results.csv\")\n\n# Write the result to a parquet file\nrel.write_parquet(\"my_results.parquet\")\n</code></pre>"},{"location":"usage/module/#something-else-heurist-duckdb","title":"Something else -&gt; Heurist DuckDB","text":"<p>DuckDB's Python client can also ingest data from other sources and Python objects. This is useful if you want to enrich / complement your Heurist data with information not available in your Heurist database.</p> <p>Read about DuckDB's Python data ingestion.</p>"},{"location":"usage/module/#other-data-files","title":"Other data files","text":"<p>You can create new tables or views in your database by reading datasets from external files.</p> <pre><code>conn.execute(\"CREATE TABLE OtherDataset AS SELECT * FROM read_csv('other_dataset.csv')\")\n</code></pre> <pre><code>conn.execute(\"CREATE TABLE OtherDataset AS SELECT * FROM read_parquet('other_dataset.parquet')\")\n</code></pre> <pre><code>conn.execute(\"CREATE TABLE OtherDataset AS SELECT * FROM read_json('other_dataset.json')\")\n</code></pre> <p>Then, from within your database connection, you can join your Heurist data with the external dataset.</p> <pre><code>sql = \"\"\"\nSELECT *\nFROM MyHeuristRecord h\nLEFT JOIN OtherDataset o\n    ON h.url = o.url\n\"\"\"\nrel = conn.sql(sql)\n</code></pre>"},{"location":"usage/module/#other-dataframes","title":"Other dataframes","text":"<p>In your DuckDB database connection, you can also select dataframes you've created with <code>pandas</code> and join them with your Heurist data.</p> <pre><code>import pandas as pd\n\nnew_dataframe = pd.DataFrame.from_dict({\n    \"insee_2025_population_total_all\": [76_452, 1_663_974],\n    \"insee_2025_population_total_women\": [38_173, 868_376],\n    \"name\": [\"Loz\u00e8re\", \"Hautes-de-Seine\"]\n})\nrel = conn.sql(\"\"\"\nSELECT *\nFROM new_dataframe df\nJOIN MyHeuristRecord h\n    ON df.name = h.department\n\"\"\")\n</code></pre>"},{"location":"usage/records/","title":"Export a record type","text":"<p>Before using the <code>heurist record</code> subcommand, review the instructions on how to configure the command-line interface (CLI).</p> <p>Documentation is under development.</p> <pre><code>heurist record -t RECORD_TYPE_ID_NUMBER\n</code></pre> <p>Specify the targeted record type with the option <code>-t</code> or <code>--record-type</code>. The subcommand <code>record</code> will call Heurist's API and download the type's records in Heurist's JSON export.</p> <pre><code>$ heurist record -t 101\nGet Records of type 101 \u280b 0:00:00\nWriting results to: RTY_101.json\n</code></pre>"},{"location":"usage/rstudio/","title":"Integrate with R-studio","text":"<p>One reason for choosing DuckDB as a pivot format is that it features a suite of clients that let you connect to the database and conduct your analyses in multiple programming languages, including Python, Node.js, R, and Java.</p>"},{"location":"usage/rstudio/#duckdbs-r-client","title":"DuckDB's R Client","text":""},{"location":"usage/rstudio/#python-set-up","title":"Python set up","text":"<p>To work with Heurist data in R, first generate the DuckDB database file using the Python command-line tool.</p>"},{"location":"usage/rstudio/#install-the-cli","title":"Install the CLI","text":"<ul> <li>Install the <code>heurist</code> Python package.</li> </ul>"},{"location":"usage/rstudio/#extract-transform-load","title":"Extract, transform, load","text":"<ul> <li>Execute the <code>download</code> command.</li> </ul> <pre><code>heurist -d YOUR_DATABASE -l \"your.login\" -p \"your-password\" download -f heurist.duckdb\n</code></pre>"},{"location":"usage/rstudio/#r-set-up","title":"R set up","text":"<p>Then, follow DuckDB's instructions for connecting to the DuckBD database file in R.</p>"},{"location":"usage/rstudio/#install-the-r-client","title":"Install the R Client","text":"<ul> <li>Install the DuckDB R Client.</li> </ul> <pre><code>install.packages(\"duckdb\")\n</code></pre>"},{"location":"usage/rstudio/#connect-to-the-duckdb-database","title":"Connect to the DuckDB database","text":"<p>Using the file path given in the <code>heurist download</code> command, i.e. <code>heurist.duckdb</code>, connect to the database file.</p> <pre><code># Load the duckdb package\nlibrary(\"duckdb\")\n\n# Connect to the database file\ncon &lt;- dbConnect(duckdb(), dbdir = \"heurist.duckdb\", read_only = FALSE)\n</code></pre>"},{"location":"usage/rstudio/#execute-sql-queries-in-r","title":"Execute SQL queries in R","text":"<p>Execute SQL queries.</p> <pre><code>res &lt;- dbGetQuery(con, \"SELECT * FROM MyHeuristRecord\")\n</code></pre>"},{"location":"usage/schema/","title":"Generate schema","text":"<p>Before using the <code>heurist schema</code> subcommand, review the instructions on how to configure the command-line interface (CLI).</p> <p>Documentation is under development.</p> <pre><code>heurist schema -t OUTPUT_TYPE\n</code></pre> <p>Specify the format in which you want to read the schema, either <code>csv</code> or <code>json</code>.</p> <pre><code>$ heurist schema -t csv\nDownloading schemas \u280b 0:00:04\nDescribing record types \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 3/3\n</code></pre>"},{"location":"usage/download/","title":"Download record groups","text":"<p>Before using the <code>heurist download</code> command, review the instructions on how to configure the command-line interface (CLI).</p> <p>Logs : Don't forget to take advantage of the logs produced by the <code>heurist download</code> command! Read about how to check your data and understand the command's results.</p>"},{"location":"usage/download/#basic-usage-my-record-types","title":"Basic usage: My record types","text":"<pre><code>heurist download -f NEW_DATABASE.db\n</code></pre> <p>By default, without specifying any target record groups, <code>heurist download</code> will download all the records you created in the \"My record types\" group. The only requirement is a path to the file for loading the results in a DuckDB database, indicated with the <code>-f</code> option.</p> <pre><code>$ heurist download -f NEW_DATABASE.db\nGet DB Structure \u283c 0:00:00\nGet Records \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 3/3 0:00:08\n\nCreated the following tables\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     name      \u2502\n\u2502    varchar    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 YourRecord_A  \u2502\n\u2502 YourRecord_B  \u2502\n\u2502 YourRecord_C  \u2502\n\u2502 dty           \u2502\n\u2502 rst           \u2502\n\u2502 rtg           \u2502\n\u2502 rty           \u2502\n\u2502 trm           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    8 rows     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The tables with lower-case names are Heurist's way of organising information about all the record types (<code>rty</code>, <code>rtg</code>), data fields (<code>dty</code>, <code>rst</code>), and vocabularies (<code>trm</code>) in the database. They're made available in case you want to access that structural information during your analysis / use of the extracted, transformed, and loaded data.</p>"},{"location":"usage/download/#more-advanced-usage","title":"More advanced usage","text":"<ul> <li><code>--outdir</code> : Export tables to CSV</li> <li><code>--record-group</code> : Record group types</li> <li><code>--user</code> : Filter by record creator</li> <li><code>--require-compound-dates</code> : Impose strict validation for dates</li> </ul>"},{"location":"usage/download/date_validation/","title":"Download record groups","text":""},{"location":"usage/download/date_validation/#require-date-fields-to-have-metadata","title":"Require date fields to have metadata","text":"<pre><code>heurist download -f NEW_DATABASE.db --require-compound-dates\n</code></pre> <p>Heurist offers a rich way of registering compound date information, including date ranges, uncertain dates, as well as details about a fuzzy date's certainty and probability distribution. However, Heurist also allows users to directly type a date estimate, i.e. a year (<code>1448</code>), in the record's field.</p> <p>If you want to confirm that all your records' dates have compound dates, with comparable metadata, use the <code>heurist download</code> command with the <code>--require-compound-dates</code> flag. This flag imposes an extra step of data validation that causes records without compound dates to be reported in the <code>logs/heurist.db.log</code> file (see the Log section) and not included in the DuckDB database produced at the end of the workflow.</p>"},{"location":"usage/download/date_validation/#example-of-an-invalid-date-field-in-the-log","title":"Example of an invalid date field in the log","text":"<p>A user can enter a year directly in a date field, without going through Heurist's compound date widget or, as in the case of CSV import, indicating a date range. When using the <code>--require-compound-dates</code> flag, this record would fail validation and be reported in the log.</p> <pre><code>2025-02-27 12:19:03,378 validation  WARNING\n    Record: text    Record ID: 47644\n    DTY: 1285   The date field was not entered as a compound Heurist date object.\n    Entered value = 1448\n</code></pre> <p>If you want to impose this strict date data validation for your analysis, go back to Heurist and change the reported record's date.</p>"},{"location":"usage/download/date_validation/#understanding-heurist-date-metadata","title":"Understanding Heurist date metadata","text":""},{"location":"usage/download/date_validation/#how-heurists-api-describes-dates","title":"How Heurist's API describes dates","text":"<p>To better understand how the <code>heurist</code> ETL package processes Heurist date data, look at how Heurist's API transmits the data stored in the database.</p>"},{"location":"usage/download/date_validation/#simple-date-detail","title":"Simple date detail","text":"<p>Simple date detail from Heurist's API:</p> <pre><code>{\n    \"dty_ID\": 1285,\n    \"value\": 1448,\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\"\n}\n</code></pre> <p>The value of a simple date detail from Heurist's API is a year or date string (i.e. <code>1448</code>). If the <code>--require-compound-dates</code> flag is used in the <code>heurist download</code> command, a simple date detail will raise a warning and cause the record to be invalid.</p>"},{"location":"usage/download/date_validation/#compound-date-detail","title":"Compound date detail","text":"<p>Compound date detail from Heurist's API:</p> <pre><code>{\n    \"dty_ID\": 1285,\n    \"value\": {\n        \"start\": {\n            \"earliest\": \"1460\"\n        },\n        \"end\": {\n            \"latest\": \"1469\"\n        },\n        \"estMinDate\": 1460,\n        \"estMaxDate\": 1469.1231\n    },\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\"\n},\n</code></pre> <p>The value of a compound date detail from Heurist's API is a map of metadata, including the data's earliest (<code>estMinDate</code>) and latest (<code>estMaxDate</code>) dates.</p>"},{"location":"usage/download/date_validation/#how-the-heurist-package-processes-compound-dates","title":"How the <code>heurist</code> package processes compound dates","text":"<p>For every 1 date field, the <code>heurist</code> ETL process creates 2 columns, which aim to (i) transform the data into an efficient format and (ii) preserve the original information returned from Heurist's API.</p>"},{"location":"usage/download/date_validation/#input-examples-from-heurist-api","title":"Input examples from Heurist API","text":"<p>Let's look at an example with a date field named <code>date_of_creation</code> and 3 records.</p> <p>Record 1: <code>date_of_creation</code> 1180 - 1200</p> <pre><code>{\n    \"start\": {\n        \"earliest\": \"1180\"\n    }, \n    \"end\": {\n        \"latest\": \"1200\"\n    }, \n    \"estMinDate\": 1180, \n    \"estMaxDate\": 1200.1231\n}\n</code></pre> <p>Record 2: <code>date_of_creation</code> in 1448 (implied, simple date)</p> <pre><code>{\n    \"dty_ID\": 1285,\n    \"value\": 1448,\n    \"fieldName\": \"date_of_creation\",\n    \"fieldType\": \"date\",\n    \"conceptID\": \"\"\n}\n</code></pre> <p>Record 3: <code>date_of_creation</code> circa 1188</p> <pre><code>{\n    \"timestamp\": {\n        \"in\": \"1188\", \n        \"type\": \"s\", \n        \"circa\": true\n    }, \n    \"comment\": \"1188\", \n    \"estMinDate\": 1188, \n    \"estMaxDate\": 1188\n}\n</code></pre>"},{"location":"usage/download/date_validation/#date-column","title":"Date column","text":"<p>The estimated minimum and maximum dates are extracted from Heurist's compound date metadata, transformed into Python <code>datetime</code> objects, arranged in an ordered list of the earliest and latest dates in the data field.</p> Record Compound Meaning <code>estMinDate</code> from API <code>estMinDate</code> from API created <code>date_of_creation</code> column 1 yes 1180 - 1200 <code>1180</code> <code>1200.1231</code> <code>[1180-01-01 00:00:00, 1200-12-31 00:00:00]</code> 2 no in 1448 <code>[1448-01-01 00:00:00, NULL]</code> 3 yes circa 1188 <code>1188</code> <code>1188</code> <code>[1188-01-01 00:00:00, 1188-01-01 00:00:00]</code>"},{"location":"usage/download/date_validation/#map-column","title":"Map column","text":"<p>In addition to the parsed <code>date_of_creation</code> column, the <code>heurist</code> ETL pipeline also preserves the response from Heurist's API in a supplemental column with the suffix <code>_TEMPORAL</code> if it is of a compound date.</p> Record created <code>date_of_creation</code> column created <code>date_of_creation_TEMPORAL</code> column 1 <code>[1180-01-01 00:00:00, 1200-12-31 00:00:00]</code> <code>{'start': {'earliest': '1180'}, 'end': {'latest': '1200'}, 'estMinDate': 1180, 'estMaxDate': 1200.1231}</code> 2 <code>[1448-01-01 00:00:00, NULL]</code> 3 <code>[1188-01-01 00:00:00, 1188-01-01 00:00:00]</code> <code>{'timestamp': {'in': '1188', 'type': 's', 'circa': True}, 'comment': '1188', 'estMinDate': 1188, 'estMaxDate': 1188}</code>"},{"location":"usage/download/export_csv/","title":"Download record groups","text":"<p>Before using the <code>heurist download</code> command, review the instructions on how to configure the command-line interface (CLI).</p> <p>Logs : Don't forget to take advantage of the logs produced by the <code>heurist download</code> command! Read about how to check your data and understand the command's results.</p>"},{"location":"usage/download/export_csv/#export-download-to-csv-files","title":"Export download to CSV files","text":"<pre><code>heurist download -f NEW_DATABASE.db -o OUTDIR/\n</code></pre> <p>By declaring the path to a directory (<code>--outdir</code>, <code>-o</code>), in addition to the required DuckDB database file path (<code>-f</code>), you can export the record tables loaded into DuckDB.</p> <p>Each CSV file name is identical with the table's name in the DuckDB database. In case your Heurist records have names that are not SQL-safe, and therefore were transformed during <code>heurist download</code>, check the <code>logs/tables.log.tsv</code> to review how your tables have been called.</p>"},{"location":"usage/download/export_csv/#example-output","title":"Example Output","text":"<p>For example, if we called <code>heurist download</code> with the option <code>-o ./tables</code>, a Heurist record type named <code>genre</code> would yield the CSV <code>./tables/Genre.csv</code>. All record tables would created in the directory <code>./tables</code>.</p> H-ID type_id preferred_name parent_genre H-ID alternative_names description described_at_URL 44167 117 chanson de geste [] Long epic poem from the Middle Ages. ['https://www.wikidata.org/wiki/Q651019', 'https://catalogue.bnf.fr/ark:/12148/cb11947470n'] 46366 117 riddaraso\u0308gur [chivalric sagas] The riddaras\u00f6gur are Norse prose sagas of the romance genre. [] 46367 117 riddaraso\u0308gur indigenous 46366 [] Icelandic indigenous creations in a style of riddaras\u00f6gur. [] 46370 117 riddaraso\u0308gur translated 46366 [] Norse translations of French chansons de geste and Latin romances and histories. []"},{"location":"usage/download/export_csv/#more-advanced-usage","title":"More advanced usage","text":"<ul> <li><code>--record-group</code> : Record group types</li> <li><code>--user</code> : Filter by record creator</li> <li><code>--require-compound-dates</code> : Impose strict validation for dates</li> </ul>"},{"location":"usage/download/group_types/","title":"Download record groups","text":"<p>Before using the <code>heurist download</code> command, review the instructions on how to configure the command-line interface (CLI).</p> <p>Logs : Don't forget to take advantage of the logs produced by the <code>heurist download</code> command! Read about how to check your data and understand the command's results.</p>"},{"location":"usage/download/group_types/#download-multiple-record-groups-records","title":"Download multiple record groups' records","text":"<pre><code>heurist download -f NEW_DATABASE.db -r \"My record types\" -r \"Place, features\"\n</code></pre> <p>If you want to load records from multiple record groups, specify each one with the option <code>-r</code> or <code>--record-group</code>.</p> <p>When using this option, the default record group (\"My record types\") is ignored. Therefore, if you want to download your custom record types, in addition to records types of other groups, do not forget to declare \"My record types\" too when using the <code>--record-group</code> option.</p> <pre><code>$ heurist download -f NEW_DATABASE.db -r \"My record types\" -r \"Place, features\"\nGet DB Structure \u283c 0:00:00\nGet Records \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 4/4 0:00:08\n\nCreated the following tables\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     name      \u2502\n\u2502    varchar    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 YourRecord_A  \u2502\n\u2502 YourRecord_B  \u2502\n\u2502 YourRecord_C  \u2502\n\u2502 Place         \u2502\n\u2502 dty           \u2502\n\u2502 rst           \u2502\n\u2502 rtg           \u2502\n\u2502 rty           \u2502\n\u2502 trm           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    9 rows     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/download/group_types/#more-advanced-usage","title":"More advanced usage","text":"<ul> <li><code>--outdir</code> : Export tables to CSV</li> <li><code>--user</code> : Filter by record creator</li> <li><code>--require-compound-dates</code> : Impose strict validation for dates</li> </ul>"},{"location":"usage/download/logs/","title":"Download record groups","text":""},{"location":"usage/download/logs/#logs","title":"Logs","text":"<p>All uses of the <code>heurist download</code> command generate a log file that helps you assess your data's validity in the Heurist database.</p> <p>This log reports every record in the Heurist database whose data does not match the schema you've designed for the record type in Heurist.</p> <ul> <li>Heurist allows users to save records that are invalid.</li> <li>The <code>heurist download</code> command requires that records' data is valid according to the schema declared in the Heurist database's architecture.</li> <li>Any records that violate the schema are not loaded into the local DuckDB database, and they are reported in the <code>heurist.db.log</code> file.</li> <li>It is advised that you go back to your Heurist database and fix the invalid records.</li> </ul>"},{"location":"usage/download/logs/#example-log-report-of-invalid-heurist-record","title":"Example log report of invalid Heurist record","text":"<p>For example, if you have designed the data field of a Heurist record to allow only 1 value, but it has been saved with multiple, an error will be logged in <code>logs/heurist.db.log</code>.</p> <pre><code>2025-02-27 10:54:04,756  validation    ERROR\n    Record: stemma  Record ID: 837\n    DTY: 1109   The detail 'note' is limited to a maximum of 1 values.\n    Count of values = 3\n</code></pre> <p>In this example, we see the problematic record has the ID <code>837</code> and is a <code>stemma</code> record. The problematic detail is <code>note</code> and it was saved with 3 values, while it should be limited to 1. In Heurist, we should either correct the record or modify the schema, then re-run the <code>heurist download</code> command. Invalid records are not loaded in the DuckDB database.</p>"},{"location":"usage/download/logs/#name-changes","title":"Name changes","text":"<p>To adapt the names of record types and data fields to PL/SQL syntax and DuckDB, sometimes changes are made. These changes are available for review in the <code>logs/tables.log.tsv</code> file.</p>"},{"location":"usage/download/logs/#reserved-names-keywords","title":"Reserved names &amp; keywords","text":"<p>When a table or column name is a reserved term or keyword in DuckDB's SQL dialect, a suffix is appended.</p> <ul> <li>Heurist record named <code>Sequence</code> \u2192 Table named <code>SequenceTable</code></li> <li>Heurist data field named <code>language</code> \u2192 Column named <code>language_COLUMN</code></li> </ul> <p>To see a current list of DuckDB's reserved keywords, connect to a DuckDB database instance and execute the command  <code>select * from duckdb_keywords();</code>.</p>"},{"location":"usage/download/logs/#foreign-keys-heurist-pointer","title":"Foreign keys / Heurist pointer","text":"<p>A Heurist record's data field can point to another Heurist record, which Heurist refers to as a \"resource\" or \"pointer.\"</p> <p>To make the CSV files that you can generate with <code>heurist download</code> useful for updating your Heurist database, we append <code>H-ID</code> to the end of every referential column, as required for Heurist import.</p> <ul> <li>Heurist pointer field named <code>is_part_of</code> -&gt; Column named <code>is_part_of H-ID</code></li> </ul>"},{"location":"usage/download/logs/#vocabulary-terms","title":"Vocabulary terms","text":"<p>When a Heurist record's data field points to a vocabulary term, the <code>heurist</code> package generates columns for both the term's label and a unique identifier (foreign key) referring to a term in the <code>trm</code> table.</p> <ul> <li> <p>Heurist vocabulary field named <code>country</code></p> <ol> <li>\u2192 Column named <code>country</code> (term's label)</li> <li>\u2192 Column named <code>country TRM-ID</code> (term's ID, refers to <code>trm</code> table)</li> </ol> </li> </ul>"},{"location":"usage/download/logs/#heurist-dates","title":"Heurist dates","text":"<p>When a Heurist record's data field is a date, the <code>heurist</code> package generates 2 columns. See a full discusion on How the <code>heurist</code> package processes compound dates.</p>"},{"location":"usage/download/user_filter/","title":"Download record groups","text":"<p>Before using the <code>heurist download</code> command, review the instructions on how to configure the command-line interface (CLI).</p> <p>Logs : Don't forget to take advantage of the logs produced by the <code>heurist download</code> command! Read about how to check your data and understand the command's results.</p>"},{"location":"usage/download/user_filter/#download-records-based-on-creator","title":"Download records based on creator","text":"<pre><code>heurist download -f NEW_DATABASE.db -u 12\n</code></pre> <p>If you want to load only a selection of records based on who created them, specify the user's Heurist ID with the option <code>-u</code> or <code>--user</code>.</p> <p>All users with access to the Heurist database are given a unique ID. You can see this information on the <code>Users</code> tab of Heurist's <code>Admin</code> panel.</p> <p></p> <p>The <code>--user</code> option can be repeated to load records for multiple users together in a DuckDB database.</p> <pre><code>heurist download -f NEW_DATABASE.db -u 12 -u 17\n</code></pre>"},{"location":"usage/download/user_filter/#more-advanced-usage","title":"More advanced usage","text":"<ul> <li><code>--outdir</code> : Export tables to CSV</li> <li><code>--record-group</code> : Record group types</li> <li><code>--require-compound-dates</code> : Impose strict validation for dates</li> </ul>"}]}